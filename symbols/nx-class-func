generators/harary_graph.py
def hnm_harary_graph(n, m, create_using=None):
def hkn_harary_graph(k, n, create_using=None):

generators/triads.py
def triad_graph(triad_name):

generators/joint_degree_seq.py
def is_valid_joint_degree(joint_degrees):
def _neighbor_switch(G, w, unsat, h_node_residual, avoid_node_id=None):
def joint_degree_graph(joint_degrees, seed=None):
def is_valid_directed_joint_degree(in_degrees, out_degrees, nkk):
def _directed_neighbor_switch(
def _directed_neighbor_switch_rev(
def directed_joint_degree_graph(in_degrees, out_degrees, nkk, seed=None):

generators/cographs.py
def random_cograph(n, seed=None):

convert_matrix.py
def to_pandas_adjacency(
def from_pandas_adjacency(df, create_using=None):
def to_pandas_edgelist(
def from_pandas_edgelist(
def to_numpy_matrix(
def from_numpy_matrix(A, parallel_edges=False, create_using=None):
def to_numpy_recarray(G, nodelist=None, dtype=None, order=None):
def to_scipy_sparse_array(G, nodelist=None, dtype=None, weight="weight", format="csr"):
def to_scipy_sparse_matrix(G, nodelist=None, dtype=None, weight="weight", format="csr"):
def from_scipy_sparse_matrix(
def _csr_gen_triples(A):
def _csc_gen_triples(A):
def _coo_gen_triples(A):
def _dok_gen_triples(A):
def _generate_weighted_edges(A):
def from_scipy_sparse_array(
def to_numpy_array(
def from_numpy_array(A, parallel_edges=False, create_using=None):

lazy_imports.py
def attach(module_name, submodules=None, submod_attrs=None):
    def __getattr__(name):
    def __dir__():
class DelayedImportErrorModule(types.ModuleType):
    def __init__(self, frame_data, *args, **kwargs):
    def __getattr__(self, x):
def lazy_import(fullname):
      def myfunc():
      def myfunc():

generators/trees.py
def prefix_tree(paths):
    def get_children(parent, paths):
def prefix_tree_recursive(paths):
    def _helper(paths, root, tree):
def random_tree(n, seed=None, create_using=None):

generators/random_graphs.py
def fast_gnp_random_graph(n, p, seed=None, directed=False):
def gnp_random_graph(n, p, seed=None, directed=False):
def dense_gnm_random_graph(n, m, seed=None):
def gnm_random_graph(n, m, seed=None, directed=False):
def newman_watts_strogatz_graph(n, k, p, seed=None):
def watts_strogatz_graph(n, k, p, seed=None):
def connected_watts_strogatz_graph(n, k, p, tries=100, seed=None):
def random_regular_graph(d, n, seed=None):
    def _suitable(edges, potential_edges):
    def _try_creation():
def _random_subset(seq, m, rng):
def barabasi_albert_graph(n, m, seed=None, initial_graph=None):
def dual_barabasi_albert_graph(n, m1, m2, p, seed=None, initial_graph=None):
def extended_barabasi_albert_graph(n, m, p, q, seed=None):
def powerlaw_cluster_graph(n, m, p, seed=None):
def random_lobster(n, p1, p2, seed=None):
def random_shell_graph(constructor, seed=None):
def random_powerlaw_tree(n, gamma=3, seed=None, tries=100):
def random_powerlaw_tree_sequence(n, gamma=3, seed=None, tries=100):
def random_kernel_graph(n, kernel_integral, kernel_root=None, seed=None):
        def kernel_root(y, a, r):
            def my_function(b):

generators/ego.py
def ego_graph(G, n, radius=1, center=True, undirected=False, distance=None):

generators/intersection.py
def uniform_random_intersection_graph(n, m, p, seed=None):
def k_random_intersection_graph(n, m, k, seed=None):
def general_random_intersection_graph(n, m, p, seed=None):

generators/random_clustered.py
def random_clustered_graph(joint_degree_sequence, create_using=None, seed=None):

generators/interval_graph.py
def interval_graph(intervals):

generators/atlas.py
def _generate_graphs():
def graph_atlas(i):
def graph_atlas_g():

generators/sudoku.py
def sudoku_graph(n=3):

generators/spectral_graph_forge.py
def _mat_spect_approx(A, level, sorteigs=True, reverse=False, absolute=True):
def spectral_graph_forge(G, alpha, transformation="identity", seed=None):

generators/expanders.py
def margulis_gabber_galil_graph(n, create_using=None):
def chordal_cycle_graph(p, create_using=None):
def paley_graph(p, create_using=None):

generators/lattice.py
def grid_2d_graph(m, n, periodic=False, create_using=None):
def grid_graph(dim, periodic=False):
def hypercube_graph(n):
def triangular_lattice_graph(
def hexagonal_lattice_graph(

generators/mycielski.py
def mycielskian(G, iterations=1):
def mycielski_graph(n):

generators/stochastic.py
def stochastic_graph(G, copy=True, weight="weight"):

generators/small.py
def _raise_on_directed(func):
    def wrapper(*args, **kwargs):
def make_small_undirected_graph(graph_description, create_using=None):
def make_small_graph(graph_description, create_using=None):
def LCF_graph(n, shift_list, repeats, create_using=None):
def bull_graph(create_using=None):
def chvatal_graph(create_using=None):
def cubical_graph(create_using=None):
def desargues_graph(create_using=None):
def diamond_graph(create_using=None):
def dodecahedral_graph(create_using=None):
def frucht_graph(create_using=None):
def heawood_graph(create_using=None):
def hoffman_singleton_graph():
def house_graph(create_using=None):
def house_x_graph(create_using=None):
def icosahedral_graph(create_using=None):
def krackhardt_kite_graph(create_using=None):
def moebius_kantor_graph(create_using=None):
def octahedral_graph(create_using=None):
def pappus_graph():
def petersen_graph(create_using=None):
def sedgewick_maze_graph(create_using=None):
def tetrahedral_graph(create_using=None):
def truncated_cube_graph(create_using=None):
def truncated_tetrahedron_graph(create_using=None):
def tutte_graph(create_using=None):

generators/internet_as_graphs.py
def uniform_int_from_avg(a, m, seed):
def choose_pref_attach(degs, seed):
class AS_graph_generator:
    def __init__(self, n, seed):
    def t_graph(self):
    def add_edge(self, i, j, kind):
    def choose_peer_pref_attach(self, node_list):
    def choose_node_pref_attach(self, node_list):
    def add_customer(self, i, j):
    def add_node(self, i, kind, reg2prob, avg_deg, t_edge_prob):
    def add_m_peering_link(self, m, to_kind):
    def add_cp_peering_link(self, cp, to_kind):
    def graph_regions(self, rn):
    def add_peering_links(self, from_kind, to_kind):
    def generate(self):
def random_internet_as_graph(n, seed=None):

generators/duplication.py
def partial_duplication_graph(N, n, p, q, seed=None):
def duplication_divergence_graph(n, p, seed=None):

generators/classic.py
def _tree_edges(n, r):
def full_rary_tree(r, n, create_using=None):
def balanced_tree(r, h, create_using=None):
def barbell_graph(m1, m2, create_using=None):
def binomial_tree(n, create_using=None):
def complete_graph(n, create_using=None):
def circular_ladder_graph(n, create_using=None):
def circulant_graph(n, offsets, create_using=None):
def cycle_graph(n, create_using=None):
def dorogovtsev_goltsev_mendes_graph(n, create_using=None):
def empty_graph(n=0, create_using=None, default=Graph):
def ladder_graph(n, create_using=None):
def lollipop_graph(m, n, create_using=None):
def null_graph(create_using=None):
def path_graph(n, create_using=None):
def star_graph(n, create_using=None):
def trivial_graph(create_using=None):
def turan_graph(n, r):
def wheel_graph(n, create_using=None):
def complete_multipartite_graph(*subset_sizes):

generators/tests/test_nonisomorphic_trees.py
class TestGeneratorNonIsomorphicTrees:
    def test_tree_structure(self):
        def f(x):
    def test_nonisomorphism(self):
        def f(x):
    def test_number_of_nonisomorphic_trees(self):
    def test_nonisomorphic_trees(self):
        def f(x):
    def test_nonisomorphic_trees_matrix(self):

generators/tests/test_random_clustered.py
class TestRandomClusteredGraph:
    def test_valid(self):
    def test_valid2(self):
    def test_invalid1(self):
    def test_invalid2(self):

generators/community.py
def caveman_graph(l, k):
def connected_caveman_graph(l, k):
def relaxed_caveman_graph(l, k, p, seed=None):
def random_partition_graph(sizes, p_in, p_out, seed=None, directed=False):
def planted_partition_graph(l, k, p_in, p_out, seed=None, directed=False):
def gaussian_random_partition_graph(n, s, v, p_in, p_out, directed=False, seed=None):
def ring_of_cliques(num_cliques, clique_size):
def windmill_graph(n, k):
def stochastic_block_model(
def _zipf_rv_below(gamma, xmin, threshold, seed):
def _powerlaw_sequence(gamma, low, high, condition, length, max_iters, seed):
def _hurwitz_zeta(x, q, tolerance):
def _generate_min_degree(gamma, average_degree, max_degree, tolerance, max_iters):
        def zeta(x, q):
def _generate_communities(degree_seq, community_sizes, mu, max_iters, seed):
def LFR_benchmark_graph(
    def condition(seq):
    def length(seq):
    def condition(seq):
    def length(seq):

generators/tests/test_mycielski.py
class TestMycielski:
    def test_construction(self):
    def test_size(self):
    def test_mycielski_graph_generator(self):

generators/tests/test_joint_degree_seq.py
def test_is_valid_joint_degree():
def test_joint_degree_graph(ntimes=10):
def test_is_valid_directed_joint_degree():
def test_directed_joint_degree_graph(n=15, m=100, ntimes=1000):

generators/tests/test_cographs.py
def test_random_cograph():

generators/tests/test_stochastic.py
class TestStochasticGraph:
    def test_default_weights(self):
    def test_in_place(self):
    def test_arbitrary_weights(self):
    def test_multidigraph(self):
    def test_graph_disallowed(self):
    def test_multigraph_disallowed(self):

generators/tests/test_ego.py
class TestGeneratorEgo:
    def test_ego(self):
    def test_ego_distance(self):

generators/tests/test_degree_seq.py
class TestConfigurationModel:
    def test_empty_degree_sequence(self):
    def test_degree_zero(self):
    def test_degree_sequence(self):
    def test_random_seed(self):
    def test_directed_disallowed(self):
    def test_odd_degree_sum(self):
def test_directed_configuation_raise_unequal():
def test_directed_configuation_model():
def test_simple_directed_configuation_model():
def test_expected_degree_graph_empty():
def test_expected_degree_graph():
def test_expected_degree_graph_selfloops():
def test_expected_degree_graph_skew():
def test_havel_hakimi_construction():
def test_directed_havel_hakimi():
def test_degree_sequence_tree():
def test_random_degree_sequence_graph():
def test_random_degree_sequence_graph_raise():
def test_random_degree_sequence_large():

generators/tests/test_classic.py
class TestGeneratorClassic:
    def test_balanced_tree(self):
    def test_balanced_tree_star(self):
    def test_balanced_tree_path(self):
    def test_full_rary_tree(self):
    def test_full_rary_tree_balanced(self):
    def test_full_rary_tree_path(self):
    def test_full_rary_tree_empty(self):
    def test_full_rary_tree_3_20(self):
    def test_barbell_graph(self):
    def test_binomial_tree(self):
    def test_complete_graph(self):
    def test_complete_digraph(self):
    def test_circular_ladder_graph(self):
    def test_circulant_graph(self):
    def test_cycle_graph(self):
    def test_dorogovtsev_goltsev_mendes_graph(self):
    def test_create_using(self):
    def test_empty_graph(self):
    def test_ladder_graph(self):
    def test_lollipop_graph(self):
    def test_null_graph(self):
    def test_path_graph(self):
    def test_star_graph(self):
    def test_trivial_graph(self):
    def test_turan_graph(self):
    def test_wheel_graph(self):
    def test_complete_0_partite_graph(self):
    def test_complete_1_partite_graph(self):
    def test_complete_2_partite_graph(self):
    def test_complete_multipartite_graph(self):

generators/tests/test_geometric.py
def l1dist(x, y):
class TestRandomGeometricGraph:
    def test_number_of_nodes(self):
    def test_distances(self):
    def test_p(self):
    def test_node_names(self):
class TestSoftRandomGeometricGraph:
    def test_number_of_nodes(self):
    def test_distances(self):
    def test_p(self):
        def dist(x, y):
    def test_node_names(self):
    def test_p_dist_default(self):
    def test_p_dist_zero(self):
        def p_dist(dist):
def join(G, u, v, theta, alpha, metric):
class TestGeographicalThresholdGraph:
    def test_number_of_nodes(self):
    def test_distances(self):
    def test_metric(self):
    def test_p_dist_zero(self):
        def p_dist(dist):
class TestWaxmanGraph:
    def test_number_of_nodes_1(self):
    def test_number_of_nodes_2(self):
    def test_metric(self):
class TestNavigableSmallWorldGraph:
    def test_navigable_small_world(self):
class TestThresholdedRandomGeometricGraph:
    def test_number_of_nodes(self):
    def test_distances(self):
    def test_p(self):
        def dist(x, y):
    def test_node_names(self):
    def test_theta(self):

generators/tests/test_lattice.py
class TestGrid2DGraph:
    def test_number_of_vertices(self):
    def test_degree_distribution(self):
    def test_directed(self):
    def test_multigraph(self):
    def test_periodic(self):
    def test_periodic_iterable(self):
    def test_periodic_directed(self):
    def test_periodic_multigraph(self):
    def test_node_input(self):
class TestGridGraph:
    def test_grid_graph(self):
    def test_node_input(self):
    def test_periodic_iterable(self):
class TestHypercubeGraph:
    def test_special_cases(self):
    def test_degree_distribution(self):
class TestTriangularLatticeGraph:
    def test_lattice_points(self):
    def test_directed(self):
    def test_multigraph(self):
    def test_periodic(self):
class TestHexagonalLatticeGraph:
    def test_lattice_points(self):
    def test_directed(self):
    def test_multigraph(self):
    def test_periodic(self):

generators/tests/test_interval_graph.py
class TestIntervalGraph:
    def test_empty(self):
    def test_interval_graph_check_invalid(self):
    def test_interval_graph_0(self):
    def test_interval_graph_1(self):
    def test_interval_graph_2(self):
    def test_interval_graph_3(self):
    def test_interval_graph_4(self):
    def test_interval_graph_5(self):

generators/tests/test_spectral_graph_forge.py
def test_spectral_graph_forge():

generators/tests/test_triads.py
def test_triad_graph():
def test_invalid_name():

generators/tests/test_trees.py
def test_basic_prefix_tree(prefix_tree_fn):
    def source_label(v):
def test_implementations_consistent(strings):
def test_random_tree():

generators/tests/test_random_graphs.py
def test_gnp_generators_negative_edge_probability(generator, directed):
def test_gnp_generators_greater_than_1_edge_probability(
def test_gnp_generators_basic(generator, directed):
def test_gnp_generators_for_p_close_to_1(generator):
def test_gnp_generators_edge_probability(generator, p, directed):
def test_gnp_random_graph_aliases(generator, seed, directed, expected_num_edges):
class TestGeneratorsRandom:
    def test_random_graph(self):
        def is_caterpillar(g):
        def is_lobster(g):
    def test_dual_barabasi_albert(self, m1=1, m2=4, p=0.5):
    def test_extended_barabasi_albert(self, m=2):
    def test_random_zero_regular_graph(self):
    def test_gnm(self):
    def test_watts_strogatz_big_k(self):
    def test_random_kernel_graph(self):
        def integral(u, w, z):
        def root(u, w, r):

generators/tests/test_sudoku.py
def test_sudoku_negative():
def test_sudoku_generator(n):

generators/tests/test_line.py
class TestGeneratorLine:
    def test_star(self):
    def test_path(self):
    def test_cycle(self):
    def test_digraph1(self):
    def test_multigraph1(self):
    def test_multigraph2(self):
    def test_multidigraph1(self):
    def test_multidigraph2(self):
    def test_digraph2(self):
    def test_create1(self):
    def test_create2(self):
class TestGeneratorInverseLine:
    def test_example(self):
    def test_example_2(self):
    def test_pair(self):
    def test_line(self):
    def test_triangle_graph(self):
    def test_cycle(self):
    def test_empty(self):
    def test_K1(self):
    def test_claw(self):
    def test_non_line_graph(self):
    def test_wrong_graph_type(self):
    def test_line_inverse_line_complete(self):
    def test_line_inverse_line_path(self):
    def test_line_inverse_line_hypercube(self):
    def test_line_inverse_line_cycle(self):
    def test_line_inverse_line_star(self):
    def test_line_inverse_line_multipartite(self):
    def test_line_inverse_line_dgm(self):
    def test_line_different_node_types(self):

generators/tests/test_internet_as_graphs.py
class TestInternetASTopology:
    def setup_class(cls):
    def set_customers(cls, i):
    def set_providers(cls, i):
    def test_wrong_input(self):
    def test_node_numbers(self):
    def test_connectivity(self):
    def test_relationships(self):
    def test_degree_values(self):

generators/tests/test_harary_graph.py
class TestHararyGraph:
    def test_hnm_harary_graph(self):
    def test_hkn_harary_graph(self):

generators/tests/test_atlas.py
class TestAtlasGraph:
    def test_index_too_small(self):
    def test_index_too_large(self):
    def test_graph(self):
class TestAtlasGraphG:
    def setup_class(cls):
    def test_sizes(self):
    def test_names(self):
    def test_nondecreasing_nodes(self):
    def test_nondecreasing_edges(self):
    def test_nondecreasing_degree_sequence(self):

generators/tests/test_expanders.py
def test_margulis_gabber_galil_graph():
def test_chordal_cycle_graph():
def test_paley_graph():
def test_margulis_gabber_galil_graph_badinput():

generators/tests/test_directed.py
class TestGeneratorsDirected:
    def test_smoke_test_random_graphs(self):
    def test_create_using_keyword_arguments(self):
class TestRandomKOutGraph:
    def test_regularity(self):
    def test_no_self_loops(self):
class TestUniformRandomKOutGraph:
    def test_regularity(self):
    def test_no_self_loops(self):
    def test_with_replacement(self):
    def test_without_replacement(self):

generators/tests/test_intersection.py
class TestIntersectionGraph:
    def test_random_intersection_graph(self):
    def test_k_random_intersection_graph(self):
    def test_k_random_intersection_graph_seeded(self):
    def test_general_random_intersection_graph(self):

generators/tests/test_duplication.py
class TestDuplicationDivergenceGraph:
    def test_final_size(self):
    def test_probability_too_large(self):
    def test_probability_too_small(self):
class TestPartialDuplicationGraph:
    def test_final_size(self):
    def test_initial_clique_size(self):
    def test_invalid_initial_size(self):
    def test_invalid_probabilities(self):

generators/tests/test_community.py
def test_random_partition_graph():
def test_planted_partition_graph():
def test_relaxed_caveman_graph():
def test_connected_caveman_graph():
def test_caveman_graph():
def test_gaussian_random_partition_graph():
def test_ring_of_cliques():
def test_windmill_graph():
def test_stochastic_block_model():
def test_generator():
def test_invalid_tau1():
def test_invalid_tau2():
def test_mu_too_large():
def test_mu_too_small():
def test_both_degrees_none():
def test_neither_degrees_none():

generators/tests/test_small.py
class TestGeneratorsSmall:
    def test_make_small_graph(self):
    def test__LCF_graph(self):
    def test_properties_named_small_graphs(self):
def tests_raises_with_directed_create_using(fn, create_using):

generators/directed.py
def gn_graph(n, kernel=None, create_using=None, seed=None):
        def kernel(x):
def gnr_graph(n, p, create_using=None, seed=None):
def gnc_graph(n, create_using=None, seed=None):
def scale_free_graph(
    def _choose_node(candidates, node_list, delta):
def random_uniform_k_out_graph(n, k, self_loops=True, with_replacement=True, seed=None):
        def sample(v, nodes):
        def sample(v, nodes):
def random_k_out_graph(n, k, alpha, self_loops=True, seed=None):

generators/nonisomorphic_trees.py
def nonisomorphic_trees(order, create="graph"):
def number_of_nonisomorphic_trees(order):
def _next_rooted_tree(predecessor, p=None):
def _next_tree(candidate):
def _split_tree(layout):
def _layout_to_matrix(layout):
def _layout_to_graph(layout):

generators/line.py
def line_graph(G, create_using=None):
def _lg_directed(G, create_using=None):
def _lg_undirected(G, selfloops=False, create_using=None):
def inverse_line_graph(G):
def _triangles(G, e):
def _odd_triangle(G, T):
def _find_partition(G, starting_cell):
def _select_starting_cell(G, starting_edge=None):

generators/social.py
def karate_club_graph():
def davis_southern_women_graph():
def florentine_families_graph():
def les_miserables_graph():

generators/geometric.py
def euclidean(x, y):
def geometric_edges(G, radius, p):
def random_geometric_graph(n, radius, dim=2, pos=None, p=2, seed=None):
def soft_random_geometric_graph(
        def p_dist(dist):
    def should_join(edge):
def geographical_threshold_graph(
        def p_dist(r):
    def should_join(pair):
def waxman_graph(
        def dist(u, v):
        def dist(u, v):
    def should_join(pair):
def navigable_small_world_graph(n, p=1, q=1, r=2, dim=2, seed=None):
def thresholded_random_geometric_graph(

__init__.py
def __getattr__(name):

generators/degree_seq.py
def _to_stublist(degree_sequence):
def _configuration_model(
def configuration_model(deg_sequence, create_using=None, seed=None):
def directed_configuration_model(
def expected_degree_graph(w, seed=None, selfloops=True):
def havel_hakimi_graph(deg_sequence, create_using=None):
def directed_havel_hakimi_graph(in_deg_sequence, out_deg_sequence, create_using=None):
def degree_sequence_tree(deg_sequence, create_using=None):
def random_degree_sequence_graph(sequence, seed=None, tries=10):
class DegreeSequenceRandomGraph:
    def __init__(self, degree, rng):
    def generate(self):
    def update_remaining(self, u, v, aux_graph=None):
    def p(self, u, v):
    def q(self, u, v):
    def suitable_edge(self):
    def phase1(self):
    def phase2(self):
    def phase3(self):

testing/test.py
def run(verbosity=1, doctest=False):

testing/utils.py
def almost_equal(x, y, places=7):
def assert_nodes_equal(nodes1, nodes2):
def assert_edges_equal(edges1, edges2):
def assert_graphs_equal(graph1, graph2):

utils/union_find.py
class UnionFind:
    def __init__(self, elements=None):
    def __getitem__(self, object):
    def __iter__(self):
    def to_sets(self):
    def union(self, *objects):

testing/tests/test_utils.py
class _GenericTest:
    def _test_equal(cls, a, b):
    def _test_not_equal(cls, a, b):
class TestNodesEqual(_GenericTest):
    def test_nodes_equal(self):
    def test_nodes_not_equal(self):
    def test_nodes_with_data_equal(self):
    def test_edges_with_data_not_equal(self):
class TestEdgesEqual(_GenericTest):
    def test_edges_equal(self):
    def test_edges_not_equal(self):
    def test_edges_with_data_equal(self):
    def test_edges_with_data_not_equal(self):
    def test_no_edges(self):
    def test_duplicate_edges(self):
    def test_duplicate_edges_with_data(self):
    def test_order_of_edges_with_data(self):
    def test_order_of_multiedges(self):
    def test_order_of_edges_with_keys(self):
class TestGraphsEqual(_GenericTest):
    def test_graphs_equal(self):
    def test_digraphs_equal(self):
    def test_multigraphs_equal(self):
    def test_multidigraphs_equal(self):
    def test_graphs_not_equal(self):
    def test_graphs_not_equal2(self):
    def test_graphs_not_equal3(self):

utils/mapped_queue.py
class _HeapElement:
    def __init__(self, priority, element):
    def __lt__(self, other):
    def __gt__(self, other):
    def __eq__(self, other):
    def __hash__(self):
    def __getitem__(self, indx):
    def __iter__(self):
    def __repr__(self):
class MappedQueue:
    def __init__(self, data=[]):
    def _heapify(self):
    def __len__(self):
    def push(self, elt, priority=None):
    def pop(self):
    def update(self, elt, new, priority=None):
    def remove(self, elt):
    def _siftup(self, pos):
    def _siftdown(self, start_pos, pos):

utils/heaps.py
class MinHeap:
    class _Item:
        def __init__(self, key, value):
        def __repr__(self):
    def __init__(self):
    def min(self):
    def pop(self):
    def get(self, key, default=None):
    def insert(self, key, value, allow_increase=False):
    def __nonzero__(self):
    def __bool__(self):
    def __len__(self):
    def __contains__(self, key):
class PairingHeap(MinHeap):
    class _Node(MinHeap._Item):
        def __init__(self, key, value):
    def __init__(self):
    def min(self):
    def pop(self):
    def get(self, key, default=None):
    def insert(self, key, value, allow_increase=False):
    def _link(self, root, other):
    def _merge_children(self, root):
    def _cut(self, node):
class BinaryHeap(MinHeap):
    def __init__(self):
    def min(self):
    def pop(self):
    def get(self, key, default=None):
    def insert(self, key, value, allow_increase=False):

utils/random_sequence.py
def powerlaw_sequence(n, exponent=2.0, seed=None):
def zipf_rv(alpha, xmin=1, seed=None):
def cumulative_distribution(distribution):
def discrete_sequence(n, distribution=None, cdistribution=None, seed=None):
def random_weighted_sample(mapping, k, seed=None):
def weighted_choice(mapping, seed=None):

utils/decorators.py
def not_implemented_for(*graph_types):
       def sp_function(G):
       def sp_np_function(G):
       def sp_np_function(G):
    def _not_implemented_for(g):
def open_file(path_arg, mode="r"):
       def read_function(pathname):
       def write_function(G, pathname):
       def write_function(G, pathname="graph.dot"):
       def write_function(G, pathname="graph.dot"):
       def another_function(arg, **kwargs):
      def some_function(arg1, arg2, path=None):
    def _open_file(path):
def nodes_or_number(which_args):
       def empty_graph(nodes):
       def empty_graph(nodes):
       def grid_2d_graph(m1, m2, periodic=False):
       def grid_2d_graph(m1, m2, periodic=False):
       def full_rary_tree(r, n)
    def _nodes_or_number(n):
def preserve_random_state(func):
        def do_random_stuff(x, y):
        def save_random_state():
        def wrapper(*args, **kwargs):
def np_random_state(random_state_argument):
       def random_float(seed=None):
       def random_float(rng=None):
       def random_array(dims, random_state=1):
def random_state(random_state_argument):
def py_random_state(random_state_argument):
       def random_float(random_state=None):
       def random_float(rng=None):
       def random_array(dims, seed=12345):
class argmap:
        def show_me_the_money(name, income):
        def convert_to(currency, which_arg):
            def _convert(amount):
        def foo(xlist, y, zlist):
        def foo(xlist, y, zlist):
        def foo(xlist, y, zlist):
        def foo(xlist, y, zlist):
        def swap(x, y):
        def foo(a, b, c):
        def foo(a, b, c):
        def double(a):
        def overflow(a, *args):
        def open_file(fn):
        def foo(file):
        def foo(file):
        def foo(file):
        def my_closing_decorator(which_arg):
            def _opener(path):
        def fancy_reader(file=None):
        def file_to_lines(file):
        def file_to_lines_wrapped(file):
        def file_to_lines_wrapper(file):
        def file_to_lines_whoops(file):
    class in broad terms to aid in understanding how to use it.
    def __init__(self, func, *args, try_finally=False):
    def _lazy_compile(func):
    def __call__(self, f):
        def func(*args, __wrapper=None, **kwargs):
    def _count(cls):
    def _name(cls, f):
    def compile(self, f):
    def assemble(self, f):
        def get_name(arg, first=True):
    def signature(cls, f):
    def _flatten(nestlist, visited):
    def _indent(*lines):

utils/tests/test_contextmanager.py
def test_reversed():

utils/rcm.py
def cuthill_mckee_ordering(G, heuristic=None):
def reverse_cuthill_mckee_ordering(G, heuristic=None):
def connected_cuthill_mckee_ordering(G, heuristic=None):
def pseudo_peripheral_node(G):

utils/contextmanagers.py
def reversed(G):

utils/tests/test_rcm.py
def test_reverse_cuthill_mckee():
def test_rcm_alternate_heuristic():
    def smallest_degree(G):

utils/tests/test__init.py
def test_utils_namespace():

utils/tests/test_misc.py
def test_flatten(nested, result):
def test_is_string_like():
def test_iterable():
def test_graph_iterable():
def test_make_list_of_ints():
def test_random_number_distribution():
def test_make_str_with_bytes():
def test_make_str_with_unicode():
class TestNumpyArray:
    def setup_class(cls):
    def test_numpy_to_list_of_ints(self):
    def test__dict_to_numpy_array1(self):
    def test__dict_to_numpy_array2(self):
    def test_dict_to_numpy_array_a(self):
    def test_dict_to_numpy_array_b(self):
def test_pairwise():
def test_groups():
def test_to_tuple():
def test_create_random_state():
def test_create_py_random_state():
def test_PythonRandomInterface_RandomState():
def test_PythonRandomInterface_Generator():
def test_arbitrary_element(iterable_type, expected):
def test_arbitrary_element_raises(iterator):
def test_dict_to_numpy_array_deprecations():

utils/tests/test_heaps.py
class X:
    def __eq__(self, other):
    def __ne__(self, other):
    def __lt__(self, other):
    def __le__(self, other):
    def __ge__(self, other):
    def __gt__(self, other):
    def __hash__(self):
def _test_heap_class(cls, *args, **kwargs):
def test_PairingHeap():
def test_BinaryHeap():

utils/tests/test_unionfind.py
def test_unionfind():
def test_subtree_union():
def test_unionfind_weights():
def test_unbalanced_merge_weights():
def test_empty_union():

utils/tests/test_random_sequence.py
def test_degree_sequences():
def test_zipf_rv():
def test_random_weighted_sample():
def test_random_weighted_choice():

utils/tests/test_mapped_queue.py
def test_HeapElement_gtlt():
def test_HeapElement_eq():
def test_HeapElement_iter():
def test_HeapElement_getitem():
class TestMappedQueue:
    def setup(self):
    def _check_map(self, q):
    def _make_mapped_queue(self, h):
    def test_heapify(self):
    def test_init(self):
    def test_len(self):
    def test_siftup_leaf(self):
    def test_siftup_one_child(self):
    def test_siftup_left_child(self):
    def test_siftup_right_child(self):
    def test_siftup_multiple(self):
    def test_siftdown_leaf(self):
    def test_siftdown_single(self):
    def test_siftdown_multiple(self):
    def test_push(self):
    def test_push_duplicate(self):
    def test_pop(self):
    def test_remove_leaf(self):
    def test_remove_root(self):
    def test_update_leaf(self):
    def test_update_root(self):
class TestMappedDict(TestMappedQueue):
    def _make_mapped_queue(self, h):
    def test_push(self):
    def test_push_duplicate(self):
    def test_update_leaf(self):
    def test_update_root(self):

tests/test_import.py
def test_namespace_alias():
def test_namespace_nesting():

utils/misc.py
def is_string_like(obj):  # from John Hunter, types-free version
def iterable(obj):
def empty_generator():
def flatten(obj, result=None):
def make_list_of_ints(sequence):
def is_list_of_ints(intlist):
def make_str(x):
def generate_unique_node():
def default_opener(filename):
def dict_to_numpy_array(d, mapping=None):
def dict_to_numpy_array2(d, mapping=None):
def _dict_to_numpy_array2(d, mapping=None):
def dict_to_numpy_array1(d, mapping=None):
def _dict_to_numpy_array1(d, mapping=None):
def is_iterator(obj):
def arbitrary_element(iterable):
def consume(iterator):
def pairwise(iterable, cyclic=False):
def groups(many_to_one):
def to_tuple(x):
def create_random_state(random_state=None):
class PythonRandomInterface:
    def __init__(self, rng=None):
    def random(self):
    def uniform(self, a, b):
    def randrange(self, a, b=None):
    def choice(self, seq):
    def gauss(self, mu, sigma):
    def shuffle(self, seq):
    def sample(self, seq, k):
    def randint(self, a, b):
    def expovariate(self, scale):
    def paretovariate(self, shape):
def create_py_random_state(random_state=None):
def nodes_equal(nodes1, nodes2):
def edges_equal(edges1, edges2):
def graphs_equal(graph1, graph2):

utils/tests/test_decorators.py
def test_not_implemented_decorator():
    def test_d(G):
    def test_u(G):
    def test_m(G):
    def test_g(G):
    def test_not_md(G):
    def test_graph_only(G):
def test_not_implemented_decorator_key():
        def test1(G):
def test_not_implemented_decorator_raise():
        def test1(G):
class TestOpenFileDecorator:
    def setup_method(self):
    def teardown_method(self):
    def write(self, path):
    def read(self, path):
    def writer_arg0(path):
    def writer_arg1(self, path):
    def writer_arg2default(self, x, path=None):
    def writer_arg4default(self, x, y, other="hello", path=None, **kwargs):
    def writer_kwarg(self, **kwargs):
    def test_writer_arg0_str(self):
    def test_writer_arg0_fobj(self):
    def test_writer_arg0_pathlib(self):
    def test_writer_arg1_str(self):
    def test_writer_arg1_fobj(self):
    def test_writer_arg2default_str(self):
    def test_writer_arg2default_fobj(self):
    def test_writer_arg2default_fobj_path_none(self):
    def test_writer_arg4default_fobj(self):
    def test_writer_kwarg_str(self):
    def test_writer_kwarg_fobj(self):
    def test_writer_kwarg_path_none(self):
def test_preserve_random_state():
class TestRandomState:
    def setup_class(cls):
    def instantiate_np_random_state(self, random_state):
    def instantiate_py_random_state(self, random_state):
    def test_random_state_None(self):
    def test_random_state_np_random(self):
    def test_random_state_int(self):
    def test_random_state_np_random_RandomState(self):
    def test_random_state_py_random(self):
def test_random_state_string_arg_index():
        def make_random_state(rs):
def test_py_random_state_string_arg_index():
        def make_random_state(rs):
def test_random_state_invalid_arg_index():
        def make_random_state(rs):
def test_py_random_state_invalid_arg_index():
        def make_random_state(rs):
class TestArgmap:
    class ArgmapError(RuntimeError):
    def test_trivial_function(self):
        def do_not_call(x):
        def trivial_argmap():
    def test_trivial_iterator(self):
        def do_not_call(x):
        def trivial_argmap():
    def test_contextmanager(self):
        def contextmanager(x):
        def foo(x, y, z):
    def test_tryfinally_generator(self):
        def singleton(x):
            def foo(x, y, z):
        def foo(x, y, z):
    def test_actual_vararg(self):
        def foo(x, y, *args):
    def test_signature_destroying_intermediate_decorator(self):
        def add_one_to_first_bad_decorator(f):
            def decorated(a, *args, **kwargs):
        def add_one_and_two(a, b):
    def test_actual_kwarg(self):
        def foo(*, arg):
    def test_nested_tuple(self):
        def xform(x, y):
        def foo(a, *args, **kwargs):
    def test_flatten(self):
    def test_indent(self):
    def test_immediate_raise(self):
        def yield_nodes(G):

tests/test_all_random_functions.py
def t(f, *args, **kwds):
def run_all_random_functions(seed):
    def kernel_integral(u, w, z):
def test_rng_interface():

tests/test_convert_scipy.py
class TestConvertScipy:
    def setup_method(self):
    def test_exceptions(self):
        class G:
    def create_weighted(self, G):
    def identity_conversion(self, G, A, create_using):
    def test_shape(self):
    def test_identity_graph_matrix(self):
    def test_identity_digraph_matrix(self):
    def test_identity_weighted_graph_matrix(self):
    def test_identity_weighted_digraph_matrix(self):
    def test_nodelist(self):
    def test_weight_keyword(self):
    def test_format_keyword(self):
    def test_format_keyword_raise(self):
    def test_null_raise(self):
    def test_empty(self):
    def test_ordering(self):
    def test_selfloop_graph(self):
    def test_selfloop_digraph(self):
    def test_from_scipy_sparse_array_parallel_edges(self):
    def test_symmetric(self):
def test_from_scipy_sparse_array_formats(sparse_format):
def test_scipy_sparse_matrix_deprecations():

tests/test_convert.py
class TestConvert:
    def edgelists_equal(self, e1, e2):
    def test_simple_graphs(self):
    def test_exceptions(self):
        class G:
        class G:
        class G:
    def test_digraphs(self):
    def test_graph(self):
    def test_with_multiedges_self_loops(self):
    def test_edgelists(self):
    def test_directed_to_undirected(self):
    def test_attribute_dict_integrity(self):
    def test_to_edgelist(self):
    def test_custom_node_attr_dict_safekeeping(self):
        class custom_dict(dict):
        class Custom(nx.Graph):
def test_to_dict_of_dicts_with_edgedata_param(edgelist):
def test_to_dict_of_dicts_with_edgedata_and_nodelist():
def test_to_dict_of_dicts_with_edgedata_multigraph():
def test_to_networkx_graph_non_edgelist():

convert.py
def to_networkx_graph(data, create_using=None, multigraph_input=False):
def to_dict_of_lists(G, nodelist=None):
def from_dict_of_lists(d, create_using=None):
def to_dict_of_dicts(G, nodelist=None, edge_data=None):
def from_dict_of_dicts(d, create_using=None, multigraph_input=False):
def to_edgelist(G, nodelist=None):
def from_edgelist(edgelist, create_using=None):

algorithms/smetric.py
def s_metric(G, normalized=True):

algorithms/distance_regular.py
def is_distance_regular(G):
def global_parameters(b, c):
def intersection_array(G):
def is_strongly_regular(G):

algorithms/d_separation.py
def d_separated(G, x, y, z):

algorithms/cycles.py
def cycle_basis(G, root=None):
def simple_cycles(G):
    def _unblock(thisnode, blocked, B):
def recursive_simple_cycles(G):
    def _unblock(thisnode):
    def circuit(thisnode, startnode, component):
def find_cycle(G, source=None, orientation=None):
        def tailhead(edge):
        def tailhead(edge):
        def tailhead(edge):
def minimum_cycle_basis(G, weight=None):
def _min_cycle_basis(comp, weight):
def _min_cycle(G, orth, weight=None):
def _path_to_cycle(path):

algorithms/assortativity/correlation.py
def degree_assortativity_coefficient(G, x="out", y="in", weight=None, nodes=None):
def degree_pearson_correlation_coefficient(G, x="out", y="in", weight=None, nodes=None):
def attribute_assortativity_coefficient(G, attribute, nodes=None):
def numeric_assortativity_coefficient(G, attribute, nodes=None):
def attribute_ac(M):
def _numeric_ac(M, mapping):

algorithms/planarity.py
def is_planar(G):
def check_planarity(G, counterexample=False):
def check_planarity_recursive(G, counterexample=False):
def get_counterexample(G):
def get_counterexample_recursive(G):
class Interval:
    def __init__(self, low=None, high=None):
    def empty(self):
    def copy(self):
    def conflicting(self, b, planarity_state):
class ConflictPair:
    def __init__(self, left=Interval(), right=Interval()):
    def swap(self):
    def lowest(self, planarity_state):
def top_of_stack(l):
class LRPlanarity:
    def __init__(self, G):
    def lr_planarity(self):
    def lr_planarity_recursive(self):
    def dfs_orientation(self, v):
    def dfs_orientation_recursive(self, v):
    def dfs_testing(self, v):
    def dfs_testing_recursive(self, v):
    def add_constraints(self, ei, e):
    def remove_back_edges(self, e):
    def dfs_embedding(self, v):
    def dfs_embedding_recursive(self, v):
    def sign(self, e):
    def sign_recursive(self, e):
class PlanarEmbedding(nx.DiGraph):
    def get_data(self):
    def set_data(self, data):
    def neighbors_cw_order(self, v):
    def check_structure(self):
    def add_half_edge_ccw(self, start_node, end_node, reference_neighbor):
    def add_half_edge_cw(self, start_node, end_node, reference_neighbor):
    def connect_components(self, v, w):
    def add_half_edge_first(self, start_node, end_node):
    def next_face_half_edge(self, v, w):
    def traverse_face(self, v, w, mark_half_edges=None):
    def is_directed(self):

algorithms/assortativity/mixing.py
def attribute_mixing_dict(G, attribute, nodes=None, normalized=False):
def attribute_mixing_matrix(G, attribute, nodes=None, mapping=None, normalized=True):
def degree_mixing_dict(G, x="out", y="in", weight=None, nodes=None, normalized=False):
def degree_mixing_matrix(
def numeric_mixing_matrix(G, attribute, nodes=None, normalized=True, mapping=None):
def mixing_dict(xy, normalized=False):

algorithms/flow/edmondskarp.py
def edmonds_karp_core(R, s, t, cutoff):
    def augment(path):
    def bidirectional_bfs():
def edmonds_karp_impl(G, s, t, capacity, residual, cutoff):
def edmonds_karp(

algorithms/flow/networksimplex.py
class _DataEssentialsAndFunctions:
    def __init__(
    def initialize_spanning_tree(self, n, faux_inf):
    def find_apex(self, p, q):
    def trace_path(self, p, w):
    def find_cycle(self, i, p, q):
    def augment_flow(self, Wn, We, f):
    def trace_subtree(self, p):
    def remove_edge(self, s, t):
    def make_root(self, q):
    def add_edge(self, i, p, q):
    def update_potentials(self, i, p, q):
    def reduced_cost(self, i):
    def find_entering_edges(self):
    def residual_capacity(self, i, p):
    def find_leaving_edge(self, Wn, We):
def network_simplex(G, demand="demand", capacity="capacity", weight="weight"):
    def add_entry(e):

algorithms/flow/shortestaugmentingpath.py
def shortest_augmenting_path_impl(G, s, t, capacity, residual, two_phase, cutoff):
    def augment(path):
    def relabel(u):
def shortest_augmenting_path(

algorithms/flow/preflowpush.py
def preflow_push_impl(G, s, t, capacity, residual, global_relabel_freq, value_only):
    def reverse_bfs(src):
    def push(u, v, flow):
    def activate(v):
    def relabel(u):
    def discharge(u, is_phase1):
    def gap_heuristic(height):
    def global_relabel(from_sink):
def preflow_push(

algorithms/flow/mincost.py
def min_cost_flow_cost(G, demand="demand", capacity="capacity", weight="weight"):
def min_cost_flow(G, demand="demand", capacity="capacity", weight="weight"):
def cost_of_flow(G, flowDict, weight="weight"):
def max_flow_min_cost(G, s, t, capacity="capacity", weight="weight"):

algorithms/flow/utils.py
class CurrentEdge:
    def __init__(self, edges):
    def get(self):
    def move_to_next(self):
    def _rewind(self):
class Level:
    def __init__(self):
class GlobalRelabelThreshold:
    def __init__(self, n, m, freq):
    def add_work(self, work):
    def is_reached(self):
    def clear_work(self):
def build_residual_network(G, capacity):
def detect_unboundedness(R, s, t):
def build_flow_dict(G, R):

algorithms/flow/tests/test_gomory_hu.py
class TestGomoryHuTree:
    def minimum_edge_weight(self, T, u, v):
    def compute_cutset(self, G, T_orig, edge):
    def test_default_flow_function_karate_club_graph(self):
    def test_karate_club_graph(self):
    def test_davis_southern_women_graph(self):
    def test_florentine_families_graph(self):
    def test_les_miserables_graph_cutset(self):
    def test_karate_club_graph_cutset(self):
    def test_wikipedia_example(self):
    def test_directed_raises(self):
    def test_empty_raises(self):

algorithms/flow/tests/test_mincost.py
class TestMinCostFlow:
    def test_simple_digraph(self):
    def test_negcycle_infcap(self):
    def test_sum_demands_not_zero(self):
    def test_no_flow_satisfying_demands(self):
    def test_transshipment(self):
    def test_max_flow_min_cost(self):
    def test_digraph1(self):
    def test_digraph2(self):
    def test_digraph3(self):
    def test_zero_capacity_edges(self):
    def test_digon(self):
    def test_deadend(self):
    def test_infinite_capacity_neg_digon(self):
    def test_finite_capacity_neg_digon(self):
    def test_multidigraph(self):
    def test_negative_selfloops(self):
    def test_bone_shaped(self):
    def test_exceptions(self):
    def test_large(self):

algorithms/flow/tests/test_networksimplex.py
def simple_flow_graph():
def simple_no_flow_graph():
def get_flowcost_from_flowdict(G, flowDict):
def test_infinite_demand_raise(simple_flow_graph):
def test_neg_infinite_demand_raise(simple_flow_graph):
def test_infinite_weight_raise(simple_flow_graph):
def test_nonzero_net_demand_raise(simple_flow_graph):
def test_negative_capacity_raise(simple_flow_graph):
def test_no_flow_satisfying_demands(simple_no_flow_graph):
def test_sum_demands_not_zero(simple_no_flow_graph):
def test_google_or_tools_example():
def test_google_or_tools_example2():
def test_large():
def test_simple_digraph():
def test_negcycle_infcap():
def test_transshipment():
def test_digraph1():
def test_zero_capacity_edges():
def test_digon():
def test_deadend():
def test_infinite_capacity_neg_digon():
def test_multidigraph():
def test_negative_selfloops():
def test_bone_shaped():
def test_graphs_type_exceptions():

algorithms/flow/tests/test_maxflow.py
def compute_cutset(G, partition):
def validate_flows(G, s, t, flowDict, solnValue, capacity, flow_func):
def validate_cuts(G, s, t, solnValue, partition, capacity, flow_func):
def compare_flows_and_cuts(G, s, t, solnFlows, solnValue, capacity="capacity"):
class TestMaxflowMinCutCommon:
    def test_graph1(self):
    def test_graph2(self):
    def test_digraph1(self):
    def test_digraph2(self):
    def test_digraph3(self):
    def test_digraph4(self):
    def test_wikipedia_dinitz_example(self):
    def test_optional_capacity(self):
    def test_digraph_infcap_edges(self):
    def test_digraph_infcap_path(self):
    def test_graph_infcap_edges(self):
    def test_digraph5(self):
    def test_disconnected(self):
    def test_source_target_not_in_graph(self):
    def test_source_target_coincide(self):
    def test_multigraphs_raise(self):
class TestMaxFlowMinCutInterface:
    def setup(self):
    def test_flow_func_not_callable(self):
    def test_flow_func_parameters(self):
    def test_minimum_cut_no_cutoff(self):
    def test_kwargs(self):
    def test_kwargs_default_flow_func(self):
    def test_reusing_residual(self):
def test_preflow_push_global_relabel_freq():
def test_preflow_push_makes_enough_space():
def test_shortest_augmenting_path_two_phase():
class TestCutoff:
    def test_cutoff(self):
    def test_complete_graph_cutoff(self):

algorithms/flow/tests/test_maxflow_large_graph.py
def gen_pyramid(N):
def read_graph(name):
def validate_flows(G, s, t, soln_value, R, flow_func):
class TestMaxflowLargeGraph:
    def test_complete_graph(self):
    def test_pyramid(self):
    def test_gl1(self):
    def test_gw1(self):
    def test_wlm3(self):
    def test_preflow_push_global_relabel(self):

algorithms/flow/gomory_hu.py
def gomory_hu_tree(G, capacity="capacity", flow_func=None):

algorithms/flow/dinitz_alg.py
def dinitz(G, s, t, capacity="capacity", residual=None, value_only=False, cutoff=None):
def dinitz_impl(G, s, t, capacity, residual, cutoff):
    def breath_first_search():
    def depth_first_search(parents):

algorithms/flow/maxflow.py
def maximum_flow(flowG, _s, _t, capacity="capacity", flow_func=None, **kwargs):
def maximum_flow_value(flowG, _s, _t, capacity="capacity", flow_func=None, **kwargs):
def minimum_cut(flowG, _s, _t, capacity="capacity", flow_func=None, **kwargs):
def minimum_cut_value(flowG, _s, _t, capacity="capacity", flow_func=None, **kwargs):

algorithms/flow/capacityscaling.py
def _detect_unboundedness(R):
def _build_residual_network(G, demand, capacity, weight):
def _build_flow_dict(G, R, capacity, weight):
def capacity_scaling(

algorithms/assortativity/pairs.py
def node_attribute_xy(G, attribute, nodes=None):
def node_degree_xy(G, x="out", y="in", weight=None, nodes=None):

algorithms/assortativity/neighbor_degree.py
def average_neighbor_degree(G, source="out", target="out", nodes=None, weight=None):

algorithms/assortativity/tests/test_neighbor_degree.py
class TestAverageNeighbor:
    def test_degree_p4(self):
    def test_degree_p4_weighted(self):
    def test_degree_k4(self):
    def test_degree_k4_nodes(self):
    def test_degree_barrat(self):
    def test_error_invalid_source_target(self):

algorithms/assortativity/tests/test_pairs.py
class TestAttributeMixingXY(BaseTestAttributeMixing):
    def test_node_attribute_xy_undirected(self):
    def test_node_attribute_xy_undirected_nodes(self):
    def test_node_attribute_xy_directed(self):
    def test_node_attribute_xy_multigraph(self):
    def test_node_attribute_xy_selfloop(self):
class TestDegreeMixingXY(BaseTestDegreeMixing):
    def test_node_degree_xy_undirected(self):
    def test_node_degree_xy_undirected_nodes(self):
    def test_node_degree_xy_directed(self):
    def test_node_degree_xy_multigraph(self):
    def test_node_degree_xy_selfloop(self):
    def test_node_degree_xy_weighted(self):

algorithms/assortativity/connectivity.py
def average_degree_connectivity(
def k_nearest_neighbors(G, source="in+out", target="in+out", nodes=None, weight=None):

algorithms/flow/boykovkolmogorov.py
def boykov_kolmogorov(
def boykov_kolmogorov_impl(G, s, t, capacity, residual, cutoff):
    def grow():
    def augment(u, v):
    def adopt():
    def _has_valid_root(n, tree):
    def _is_closer(u, v):

algorithms/assortativity/tests/test_connectivity.py
class TestNeighborConnectivity:
    def test_degree_p4(self):
    def test_degree_p4_weighted(self):
    def test_weight_keyword(self):
    def test_degree_barrat(self):
    def test_zero_deg(self):
    def test_in_out_weight(self):
    def test_invalid_source(self):
    def test_invalid_target(self):
    def test_invalid_undirected_graph(self):
    def test_single_node(self):

algorithms/euler.py
def is_eulerian(G):
def is_semieulerian(G):
def _find_path_start(G):
def _simplegraph_eulerian_circuit(G, source):
def _multigraph_eulerian_circuit(G, source):
def eulerian_circuit(G, source=None, keys=False):
def has_eulerian_path(G, source=None):
def eulerian_path(G, source=None, keys=False):
def eulerize(G):

algorithms/assortativity/tests/base_test.py
class BaseTestAttributeMixing:
    def setup_class(cls):
class BaseTestDegreeMixing:
    def setup_class(cls):
class BaseTestNumericMixing:
    def setup_class(cls):

algorithms/assortativity/tests/test_correlation.py
class TestDegreeMixingCorrelation(BaseTestDegreeMixing):
    def test_degree_assortativity_undirected(self):
    def test_degree_assortativity_directed(self):
    def test_degree_assortativity_directed2(self):
    def test_degree_assortativity_multigraph(self):
    def test_degree_pearson_assortativity_undirected(self):
    def test_degree_pearson_assortativity_directed(self):
    def test_degree_pearson_assortativity_directed2(self):
    def test_degree_pearson_assortativity_multigraph(self):
    def test_degree_assortativity_weighted(self):
    def test_degree_assortativity_double_star(self):
class TestAttributeMixingCorrelation(BaseTestAttributeMixing):
    def test_attribute_assortativity_undirected(self):
    def test_attribute_assortativity_directed(self):
    def test_attribute_assortativity_multigraph(self):
    def test_attribute_assortativity_coefficient(self):
    def test_attribute_assortativity_coefficient2(self):
    def test_attribute_assortativity(self):
class TestNumericMixingCorrelation(BaseTestNumericMixing):
    def test_numeric_assortativity_negative(self):
    def test_numeric_assortativity_float(self):
    def test_numeric_assortativity_mixed(self):

algorithms/assortativity/tests/test_mixing.py
class TestDegreeMixingDict(BaseTestDegreeMixing):
    def test_degree_mixing_dict_undirected(self):
    def test_degree_mixing_dict_undirected_normalized(self):
    def test_degree_mixing_dict_directed(self):
    def test_degree_mixing_dict_multigraph(self):
    def test_degree_mixing_dict_weighted(self):
class TestDegreeMixingMatrix(BaseTestDegreeMixing):
    def test_degree_mixing_matrix_undirected(self):
    def test_degree_mixing_matrix_directed(self):
    def test_degree_mixing_matrix_multigraph(self):
    def test_degree_mixing_matrix_selfloop(self):
    def test_degree_mixing_matrix_weighted(self):
    def test_degree_mixing_matrix_mapping(self):
class TestAttributeMixingDict(BaseTestAttributeMixing):
    def test_attribute_mixing_dict_undirected(self):
    def test_attribute_mixing_dict_directed(self):
    def test_attribute_mixing_dict_multigraph(self):
class TestAttributeMixingMatrix(BaseTestAttributeMixing):
    def test_attribute_mixing_matrix_undirected(self):
    def test_attribute_mixing_matrix_directed(self):
    def test_attribute_mixing_matrix_multigraph(self):
class TestNumericMixingMatrix(BaseTestNumericMixing):
    def test_numeric_mixing_matrix_negative(self):
    def test_numeric_mixing_matrix_float(self):

algorithms/distance_measures.py
def extrema_bounding(G, compute="diameter"):
def _extrema_bounding(G, compute="diameter"):
def eccentricity(G, v=None, sp=None):
def diameter(G, e=None, usebounds=False):
def periphery(G, e=None, usebounds=False):
def radius(G, e=None, usebounds=False):
def center(G, e=None, usebounds=False):
def barycenter(G, weight=None, attr=None, sp=None):
def _count_lu_permutations(perm_array):
def resistance_distance(G, nodeA, nodeB, weight=None, invert_weight=True):

algorithms/cuts.py
def cut_size(G, S, T=None, weight=None):
def volume(G, S, weight=None):
def normalized_cut_size(G, S, T=None, weight=None):
def conductance(G, S, T=None, weight=None):
def edge_expansion(G, S, T=None, weight=None):
def mixing_expansion(G, S, T=None, weight=None):
def node_expansion(G, S):
def boundary_expansion(G, S):

algorithms/planar_drawing.py
def combinatorial_embedding_to_pos(embedding, fully_triangulate=False):
def set_position(parent, tree, remaining_nodes, delta_x, y_coordinate, pos):
def get_canonical_ordering(embedding, outer_face):
    def is_outer_face_nbr(x, y):
    def is_on_outer_face(x):
def triangulate_face(embedding, v1, v2):
def triangulate_embedding(embedding, fully_triangulate=True):
def make_bi_connected(embedding, starting_node, outgoing_node, edges_counted):

algorithms/tournament.py
def index_satisfying(iterable, condition):
def is_tournament(G):
def hamiltonian_path(G):
def random_tournament(n, seed=None):
def score_sequence(G):
def tournament_matrix(G):
def is_reachable(G, s, t):
    def two_neighborhood(G, v):
    def is_closed(G, nodes):
def is_strongly_connected(G):

algorithms/link_analysis/hits_alg.py
def hits(G, max_iter=100, tol=1.0e-8, nstart=None, normalized=True):
def _hits_python(G, max_iter=100, tol=1.0e-8, nstart=None, normalized=True):
def authority_matrix(G, nodelist=None):
def hub_matrix(G, nodelist=None):
def hits_numpy(G, normalized=True):
def hits_scipy(G, max_iter=100, tol=1.0e-6, nstart=None, normalized=True):

algorithms/covering.py
def min_edge_cover(G, matching_algorithm=None):
def is_edge_cover(G, cover):

algorithms/coloring/equitable_coloring.py
def is_coloring(G, coloring):
def is_equitable(G, coloring, num_colors=None):
def make_C_from_F(F):
def make_N_from_L_C(L, C):
def make_H_from_C_N(C, N):
def change_color(u, X, Y, N, H, F, C, L):
def move_witnesses(src_color, dst_color, N, H, F, C, T_cal, L):
def pad_graph(G, num_colors):
def procedure_P(V_minus, V_plus, N, H, F, C, L, excluded_colors=None):
def equitable_color(G, num_colors):

algorithms/coloring/tests/test_coloring.py
class TestColoring:
    def test_basic_cases(self):
        def check_basic_case(graph_func, n_nodes, strategy, interchange):
    def test_special_cases(self):
        def check_special_case(strategy, graph_func, interchange, colors):
    def test_interchange_invalid(self):
    def test_bad_inputs(self):
    def test_strategy_as_function(self):
    def test_seed_argument(self):
    def test_is_coloring(self):
    def test_is_equitable(self):
    def test_num_colors(self):
    def test_equitable_color(self):
    def test_equitable_color_empty(self):
    def test_equitable_color_large(self):
    def test_case_V_plus_not_in_A_cal(self):
    def test_cast_no_solo(self):
    def test_hard_prob(self):
    def test_hardest_prob(self):
def verify_coloring(graph, coloring):
def verify_length(coloring, expected):
def dict_to_sets(colors):
def empty_graph():
def one_node_graph():
def two_node_graph():
def three_node_clique():
def disconnected():
def rs_shc():
def slf_shc():
def slf_hc():
def lf_shc():
def lf_hc():
def sl_shc():
def sl_hc():
def gis_shc():
def gis_hc():
def cs_shc():
def rsi_shc():
def lfi_shc():
def lfi_hc():
def sli_shc():
def sli_hc():
def check_state(L, N, H, F, C):
def max_degree(G):
def make_params_from_graph(G, F):

algorithms/coloring/greedy_coloring.py
def strategy_largest_first(G, colors):
def strategy_random_sequential(G, colors, seed=None):
def strategy_smallest_last(G, colors):
    def find_min_degree():
def _maximal_independent_set(G):
def strategy_independent_set(G, colors):
def strategy_connected_sequential_bfs(G, colors):
def strategy_connected_sequential_dfs(G, colors):
def strategy_connected_sequential(G, colors, traversal="bfs"):
def strategy_saturation_largest_first(G, colors):
def greedy_color(G, strategy="largest_first", interchange=False):
class _Node:
    def __init__(self, node_id, n):
    def __repr__(self):
    def assign_color(self, adj_entry, color):
    def clear_color(self, adj_entry, color):
    def iter_neighbors(self):
    def iter_neighbors_color(self, color):
class _AdjEntry:
    def __init__(self, node_id):
    def __repr__(self):
def _greedy_coloring_with_interchange(G, nodes):

algorithms/community/louvain.py
def louvain_communities(
def louvain_partitions(
def _one_level(G, m, partition, resolution=1, is_directed=False, seed=None):
def _neighbor_weights(nbrs, node2com):
def _gen_graph(G, partition):
def _convert_multigraph(G, weight, is_directed):

algorithms/community/kclique.py
def k_clique_communities(G, k, cliques=None):
def _get_adjacent_cliques(clique, membership_dict):

algorithms/community/asyn_fluid.py
def asyn_fluidc(G, k, max_iter=100, seed=None):

algorithms/triads.py
def _tricode(G, v, u, w):
def triadic_census(G, nodelist=None):
def is_triad(G):
def all_triplets(G):
def all_triads(G):
def triads_by_type(G):
def triad_type(G):
def random_triad(G):
def triadic_closures(G):
def focal_closures(G, attr_name):
def balanced_triads(G, crit_func):

algorithms/community/quality.py
class NotAPartition(NetworkXError):
    def __init__(self, G, collection):
def _require_partition(G, partition):
def intra_community_edges(G, partition):
def inter_community_edges(G, partition):
def inter_community_non_edges(G, partition):
def performance(G, partition):
def coverage(G, partition):
def modularity(G, communities, weight="weight", resolution=1):
    def community_contribution(community):
def partition_quality(G, partition):

algorithms/community/centrality.py
def girvan_newman(G, most_valuable_edge=None):
        def most_valuable_edge(G):
def _without_most_central_edges(G, most_valuable_edge):

algorithms/community/community_utils.py
def is_partition(G, communities):

algorithms/community/label_propagation.py
def asyn_lpa_communities(G, weight=None, seed=None):
def label_propagation_communities(G):
def _color_network(G):
def _labeling_complete(labeling, G):
def _most_frequent_labels(node, labeling, G):
def _update_label(node, labeling, G):

algorithms/community/kernighan_lin.py
def _kernighan_lin_sweep(edges, side):
    def _update_costs(costs_x, x):
def kernighan_lin_bisection(G, partition=None, max_iter=10, weight="weight", seed=None):

algorithms/community/lukes.py
def _split_n_from(n, min_size_of_first_part):
def lukes_partitioning(G, max_size, node_weight=None, edge_weight=None):
    def _leaves(gr):
    def _a_parent_of_leaves_only(gr):
    def _value_of_cluster(cluster):
    def _value_of_partition(partition):
    def _weight_of_cluster(cluster):
    def _pivot(partition, node):
    def _concatenate_or_merge(partition_1, partition_2, x, i, ref_weigth):

algorithms/community/modularity_max.py
def _greedy_modularity_communities_generator(G, weight=None, resolution=1):
def greedy_modularity_communities(
def naive_greedy_modularity_communities(G, resolution=1, weight=None):

algorithms/community/tests/test_louvain.py
def test_modularity_increase():
def test_valid_partition():
def test_partition():
def test_none_weight_param():
def test_quality():
def test_multigraph():
def test_resolution():
def test_threshold():

algorithms/asteroidal.py
def find_asteroidal_triple(G):
def is_at_free(G):
def create_component_structure(G):

algorithms/community/tests/test_modularity_max.py
def test_modularity_communities(func):
def test_modularity_communities_categorical_labels(func):
def test_greedy_modularity_communities_relabeled():
def test_greedy_modularity_communities_directed():
def test_modularity_communities_weighted(func):
def test_modularity_communities_floating_point():
def test_modularity_communities_directed_weighted():
def test_greedy_modularity_communities_multigraph():
def test_greedy_modularity_communities_multigraph_weighted():
def test_greed_modularity_communities_multidigraph():
def test_greed_modularity_communities_multidigraph_weighted():
def test_resolution_parameter_impact():
def test_cutoff_parameter():
def test_best_n():

algorithms/community/tests/test_quality.py
class TestPerformance:
    def test_bad_partition(self):
    def test_good_partition(self):
class TestCoverage:
    def test_bad_partition(self):
    def test_good_partition(self):
def test_modularity():
def test_modularity_resolution():
def test_inter_community_edges_with_digraphs():

algorithms/link_analysis/tests/test_hits.py
class TestHITS:
    def setup_class(cls):
    def test_hits_numpy(self):
    def test_hits(self, hits_alg):
    def test_empty(self):
    def test_hits_not_convergent(self):
def test_deprecation_warnings(hits_alg):

algorithms/community/tests/test_kernighan_lin.py
def assert_partition_equal(x, y):
def test_partition():
def test_partition_argument():
def test_partition_argument_non_integer_nodes():
def test_seed_argument():
def test_non_disjoint_partition():
def test_too_many_blocks():
def test_multigraph():
def test_max_iter_argument():

algorithms/community/tests/test_lukes.py
def paper_1_case(float_edge_wt=False, explicit_node_wt=True, directed=False):
def paper_2_case(explicit_edge_wt=True, directed=False):
def test_paper_1_case():
def test_paper_2_case():
def test_mandatory_tree():
def test_mandatory_integrality():

algorithms/community/tests/test_centrality.py
def set_of_sets(iterable):
def validate_communities(result, expected):
def validate_possible_communities(result, *expected):
class TestGirvanNewman:
    def test_no_edges(self):
    def test_undirected(self):
    def test_directed(self):
    def test_selfloops(self):
    def test_most_valuable_edge(self):
        def heaviest(G):

algorithms/community/tests/test_utils.py
def test_is_partition():
def test_not_covering():
def test_not_disjoint():
def test_not_node():

algorithms/link_analysis/tests/test_pagerank.py
class TestPageRank:
    def setup_class(cls):
    def test_pagerank(self, alg):
    def test_pagerank_max_iter(self, alg):
    def test_numpy_pagerank(self):
    def test_google_matrix(self):
    def test_personalization(self, alg):
    def test_zero_personalization_vector(self, alg):
    def test_one_nonzero_personalization_value(self, alg):
    def test_incomplete_personalization(self, alg):
    def test_dangling_matrix(self):
    def test_dangling_pagerank(self, alg):
    def test_empty(self):
    def test_multigraph(self, alg):
class TestPageRankScipy(TestPageRank):
    def test_scipy_pagerank(self):
    def test_scipy_pagerank_max_iter(self):
    def test_dangling_scipy_pagerank(self):
    def test_empty_scipy(self):
def test_deprecation_warnings(pagerank_alg):

algorithms/community/tests/test_label_propagation.py
def test_directed_not_supported():
def test_iterator_vs_iterable():
def test_one_node():
def test_unconnected_communities():
def test_connected_communities():
def test_termination():
class TestAsynLpaCommunities:
    def _check_communities(self, G, expected):
    def test_null_graph(self):
    def test_single_node(self):
    def test_simple_communities(self):
    def test_seed_argument(self):
    def test_several_communities(self):

algorithms/community/tests/test_asyn_fluid.py
def test_exceptions():
def test_single_node():
def test_two_nodes():
def test_two_clique_communities():
def test_five_clique_ring():

algorithms/community/tests/test_kclique.py
def test_overlapping_K5():
def test_isolated_K5():
class TestZacharyKarateClub:
    def setup(self):
    def _check_communities(self, k, expected):
    def test_k2(self):
    def test_k3(self):
    def test_k4(self):
    def test_k5(self):
    def test_k6(self):
def test_bad_k():

algorithms/vitality.py
def closeness_vitality(G, node=None, weight=None, wiener_index=None):

algorithms/link_analysis/pagerank_alg.py
def pagerank(
def _pagerank_python(
def google_matrix(
def pagerank_numpy(G, alpha=0.85, personalization=None, weight="weight", dangling=None):
def pagerank_scipy(

algorithms/efficiency_measures.py
def efficiency(G, u, v):
def global_efficiency(G):
def local_efficiency(G):

algorithms/link_prediction.py
def _apply_prediction(G, func, ebunch=None):
def resource_allocation_index(G, ebunch=None):
    def predict(u, v):
def jaccard_coefficient(G, ebunch=None):
    def predict(u, v):
def adamic_adar_index(G, ebunch=None):
    def predict(u, v):
def common_neighbor_centrality(G, ebunch=None, alpha=0.8):
        def predict(u, v):
        def predict(u, v):
def preferential_attachment(G, ebunch=None):
    def predict(u, v):
def cn_soundarajan_hopcroft(G, ebunch=None, community="community"):
    def predict(u, v):
def ra_index_soundarajan_hopcroft(G, ebunch=None, community="community"):
    def predict(u, v):
def within_inter_cluster(G, ebunch=None, delta=0.001, community="community"):
    def predict(u, v):
def _community(G, u, community):

algorithms/graphical.py
def is_graphical(sequence, method="eg"):
def _basic_graphical_tests(deg_sequence):
def is_valid_degree_sequence_havel_hakimi(deg_sequence):
def is_valid_degree_sequence_erdos_gallai(deg_sequence):
def is_multigraphical(sequence):
def is_pseudographical(sequence):
def is_digraphical(in_sequence, out_sequence):

algorithms/shortest_paths/astar.py
def astar_path(G, source, target, heuristic=None, weight="weight"):
        def heuristic(u, v):
def astar_path_length(G, source, target, heuristic=None, weight="weight"):

algorithms/summarization.py
def dedensify(G, threshold, prefix=None, copy=True):
def _snap_build_graph(
def _snap_eligible_group(G, groups, group_lookup, edge_types):
def _snap_split(groups, neighbor_info, group_lookup, group_id):
def snap_aggregation(

algorithms/minors/contraction.py
def equivalence_classes(iterable, relation):
def quotient_graph(
def _quotient_graph(
        def node_data(b):
        def edge_relation(b, c):
        def edge_data(b, c):
def contracted_nodes(G, u, v, self_loops=True, copy=True):
def contracted_edge(G, edge, self_loops=True, copy=True):

algorithms/shortest_paths/unweighted.py
def single_source_shortest_path_length(G, source, cutoff=None):
def _single_shortest_path_length(adj, firstlevel, cutoff):
def single_target_shortest_path_length(G, target, cutoff=None):
def all_pairs_shortest_path_length(G, cutoff=None):
def bidirectional_shortest_path(G, source, target):
def _bidirectional_pred_succ(G, source, target):
def single_source_shortest_path(G, source, cutoff=None):
    def join(p1, p2):
def _single_shortest_path(adj, firstlevel, paths, cutoff, join):
def single_target_shortest_path(G, target, cutoff=None):
    def join(p1, p2):
def all_pairs_shortest_path(G, cutoff=None):
def predecessor(G, source, target=None, cutoff=None, return_seen=None):

algorithms/shortest_paths/tests/test_dense_numpy.py
def test_cycle_numpy():
def test_weighted_numpy_three_edges():
def test_weighted_numpy_two_edges():
def test_weight_parameter_numpy():
def test_directed_cycle_numpy():
def test_zero_weight():
def test_nodelist():

algorithms/minors/tests/test_contraction.py
class TestQuotient:
    def test_quotient_graph_complete_multipartite(self):
        def same_neighbors(u, v):
    def test_quotient_graph_complete_bipartite(self):
        def same_neighbors(u, v):
    def test_quotient_graph_edge_relation(self):
        def identity(u, v):
        def same_parity(b, c):
    def test_condensation_as_quotient(self):
        def same_component(u, v):
    def test_path(self):
    def test_path__partition_provided_as_dict_of_lists(self):
    def test_path__partition_provided_as_dict_of_tuples(self):
    def test_path__partition_provided_as_dict_of_sets(self):
    def test_multigraph_path(self):
    def test_directed_path(self):
    def test_directed_multigraph_path(self):
    def test_overlapping_blocks(self):
    def test_weighted_path(self):
    def test_barbell(self):
    def test_barbell_plus(self):
    def test_blockmodel(self):
    def test_multigraph_blockmodel(self):
    def test_quotient_graph_incomplete_partition(self):
class TestContraction:
    def test_undirected_node_contraction(self):
    def test_directed_node_contraction(self):
    def test_undirected_node_contraction_no_copy(self):
    def test_directed_node_contraction_no_copy(self):
    def test_create_multigraph(self):
    def test_multigraph_keys(self):
    def test_node_attributes(self):
    def test_edge_attributes(self):
    def test_without_self_loops(self):
    def test_contract_selfloop_graph(self):
    def test_undirected_edge_contraction(self):
    def test_multigraph_edge_contraction(self):
    def test_nonexistent_edge(self):

algorithms/shortest_paths/tests/test_unweighted.py
def validate_grid_path(r, c, s, t, p):
class TestUnweightedPath:
    def setup_class(cls):
    def test_bidirectional_shortest_path(self):
    def test_shortest_path_length(self):
    def test_single_source_shortest_path(self):
    def test_single_source_shortest_path_length(self):
    def test_single_target_shortest_path(self):
    def test_single_target_shortest_path_length(self):
    def test_all_pairs_shortest_path(self):
    def test_all_pairs_shortest_path_length(self):
    def test_predecessor_path(self):
    def test_predecessor_cycle(self):
    def test_predecessor_cutoff(self):
    def test_predecessor_target(self):

algorithms/shortest_paths/tests/test_weighted.py
def validate_path(G, s, t, soln_len, path, weight="weight"):
            def weight_f(u, v, d):
            def weight_f(u, v, d):
def validate_length_path(G, s, t, soln_len, length, path, weight="weight"):
class WeightedTestBase:
    def setup(self):
class TestWeightedPath(WeightedTestBase):
    def test_dijkstra(self):
    def test_bidirectional_dijkstra(self):
    def test_weight_functions(self):
        def heuristic(*z):
        def getpath(pred, v, s):
        def goldberg_radzik(g, s, t, weight="weight"):
        def astar(g, s, t, weight="weight"):
        def vlp(G, s, t, l, F, w):
        def weight(u, v, _):
        def weight(u, v, _):
    def test_bidirectional_dijkstra_no_path(self):
    def test_absent_source(self, fn):
    def test_dijkstra_predecessor1(self):
    def test_dijkstra_predecessor2(self):
    def test_dijkstra_predecessor3(self):
    def test_single_source_dijkstra_path_length(self):
    def test_bidirectional_dijkstra_multigraph(self):
    def test_dijkstra_pred_distance_multigraph(self):
    def test_negative_edge_cycle(self):
    def test_negative_edge_cycle_custom_weight_key(self):
    def test_weight_function(self):
        def weight(u, v, d):
    def test_all_pairs_dijkstra_path(self):
    def test_all_pairs_dijkstra_path_length(self):
    def test_all_pairs_dijkstra(self):
class TestDijkstraPathLength:
    def test_weight_function(self):
        def weight(u, v, d):
class TestMultiSourceDijkstra:
    def test_no_sources(self):
    def test_path_no_sources(self):
    def test_path_length_no_sources(self):
    def test_absent_source(self, fn):
    def test_two_sources(self):
    def test_simple_paths(self):
class TestBellmanFordAndGoldbergRadzik(WeightedTestBase):
    def test_single_node_graph(self):
    def test_absent_source_bellman_ford(self):
    def test_absent_source_goldberg_radzik(self):
    def test_negative_cycle_heuristic(self):
    def test_negative_cycle_consistency(self):
    def test_negative_cycle(self):
    def test_find_negative_cycle_longer_cycle(self):
    def test_find_negative_cycle_no_cycle(self):
    def test_find_negative_cycle_single_edge(self):
    def test_negative_weight(self):
    def test_not_connected(self):
    def test_multigraph(self):
    def test_others(self):
    def test_path_graph(self):
    def test_4_cycle(self):
    def test_negative_weight_bf_path(self):
    def test_zero_cycle_smoke(self):
class TestJohnsonAlgorithm(WeightedTestBase):
    def test_single_node_graph(self):
    def test_negative_cycle(self):
    def test_negative_weights(self):
    def test_unweighted_graph(self):
    def test_graphs(self):

algorithms/shortest_paths/tests/test_dense.py
class TestFloyd:
    def setup_class(cls):
    def test_floyd_warshall_predecessor_and_distance(self):
    def test_reconstruct_path(self):
    def test_cycle(self):
    def test_weighted(self):
    def test_weighted2(self):
    def test_weight_parameter(self):
    def test_zero_distance(self):
    def test_zero_weight(self):

algorithms/shortest_paths/tests/test_astar.py
class TestAStar:
    def setup_class(cls):
    def test_multiple_optimal_paths(self):
        def h(u, v):
    def test_astar_directed(self):
    def test_astar_multigraph(self):
    def test_astar_undirected(self):
    def test_astar_directed2(self):
    def test_astar_undirected2(self):
    def test_astar_undirected3(self):
    def test_astar_directed3(self):
        def h(u, v):
    def test_astar_directed4(self):
    def test_astar_w1(self):
    def test_astar_nopath(self):
    def test_cycle(self):
    def test_unorderable_nodes(self):

algorithms/shortest_paths/dense.py
def floyd_warshall_numpy(G, nodelist=None, weight="weight"):
def floyd_warshall_predecessor_and_distance(G, weight="weight"):
def reconstruct_path(source, target, predecessors):
def floyd_warshall(G, weight="weight"):

algorithms/shortest_paths/tests/test_generic.py
def validate_grid_path(r, c, s, t, p):
class TestGenericPath:
    def setup_class(cls):
    def test_shortest_path(self):
    def test_shortest_path_target(self):
    def test_shortest_path_length(self):
    def test_shortest_path_length_target(self):
    def test_single_source_shortest_path(self):
    def test_single_source_shortest_path_length(self):
    def test_all_pairs_shortest_path(self):
    def test_all_pairs_shortest_path_length(self):
    def test_has_path(self):
    def test_all_shortest_paths(self):
    def test_all_shortest_paths_raise(self):
    def test_bad_method(self):
    def test_all_shortest_paths_zero_weight_edge(self):
class TestAverageShortestPathLength:
    def test_cycle_graph(self):
    def test_path_graph(self):
    def test_weighted(self):
    def test_specified_methods(self):
    def test_disconnected(self):
    def test_trivial_graph(self):
    def test_null_graph(self):
    def test_bad_method(self):
class TestAverageShortestPathLengthNumpy:
    def setup_class(cls):
    def test_specified_methods_numpy(self):

algorithms/mis.py
def maximal_independent_set(G, nodes=None, seed=None):

algorithms/shortest_paths/generic.py
def has_path(G, source, target):
def shortest_path(G, source=None, target=None, weight=None, method="dijkstra"):
def shortest_path_length(G, source=None, target=None, weight=None, method="dijkstra"):
def average_shortest_path_length(G, weight=None, method=None):
    def path_length(v):
def all_shortest_paths(G, source, target, weight=None, method="dijkstra"):
def _build_paths_from_predecessors(sources, target, pred):

algorithms/traversal/edgebfs.py
def edge_bfs(G, source=None, orientation=None):
        def edges_from(node):
        def edges_from(node):
        def edges_from(node):
        def edges_from(node):
        def edge_id(edge):
        def edge_id(edge):

algorithms/reciprocity.py
def reciprocity(G, nodes=None):
def _reciprocity_iter(G, nodes):
def overall_reciprocity(G):

algorithms/traversal/edgedfs.py
def edge_dfs(G, source=None, orientation=None):
        def edges_from(node):
        def edges_from(node):
        def edges_from(node):
        def edges_from(node):
        def edge_id(edge):
        def edge_id(edge):

algorithms/traversal/depth_first_search.py
def dfs_edges(G, source=None, depth_limit=None):
def dfs_tree(G, source=None, depth_limit=None):
def dfs_predecessors(G, source=None, depth_limit=None):
def dfs_successors(G, source=None, depth_limit=None):
def dfs_postorder_nodes(G, source=None, depth_limit=None):
def dfs_preorder_nodes(G, source=None, depth_limit=None):
def dfs_labeled_edges(G, source=None, depth_limit=None):

algorithms/traversal/beamsearch.py
def bfs_beam_edges(G, source, value, width=None):
    def successors(v):

algorithms/traversal/breadth_first_search.py
def generic_bfs_edges(G, source, neighbors=None, depth_limit=None, sort_neighbors=None):
def bfs_edges(G, source, reverse=False, depth_limit=None, sort_neighbors=None):
def bfs_tree(G, source, reverse=False, depth_limit=None, sort_neighbors=None):
def bfs_predecessors(G, source, depth_limit=None, sort_neighbors=None):
def bfs_successors(G, source, depth_limit=None, sort_neighbors=None):
def descendants_at_distance(G, source, distance):

algorithms/graph_hashing.py
def _hash_label(label, digest_size):
def _init_node_labels(G, edge_attr, node_attr):
def _neighborhood_aggregate(G, node, node_labels, edge_attr=None):
def weisfeiler_lehman_graph_hash(
    def weisfeiler_lehman_step(G, labels, edge_attr=None):
def weisfeiler_lehman_subgraph_hashes(
    def weisfeiler_lehman_step(G, labels, node_subgraph_hashes, edge_attr=None):

algorithms/cluster.py
def triangles(G, nodes=None):
def _triangles_and_degree_iter(G, nodes=None):
def _weighted_triangles_and_degree_iter(G, nodes=None, weight="weight"):
    def wt(u, v):
def _directed_triangles_and_degree_iter(G, nodes=None):
def _directed_weighted_triangles_and_degree_iter(G, nodes=None, weight="weight"):
    def wt(u, v):
def average_clustering(G, nodes=None, weight=None, count_zeros=True):
def clustering(G, nodes=None, weight=None):
def transitivity(G):
def square_clustering(G, nodes=None):
def generalized_degree(G, nodes=None):

algorithms/traversal/tests/test_beamsearch.py
def identity(x):
class TestBeamSearch:
    def test_narrow(self):
    def test_wide(self):

algorithms/traversal/tests/test_bfs.py
class TestBFS:
    def setup_class(cls):
    def test_successor(self):
    def test_predecessor(self):
    def test_bfs_tree(self):
    def test_bfs_edges(self):
    def test_bfs_edges_reverse(self):
    def test_bfs_edges_sorting(self):
    def test_bfs_tree_isolates(self):
    def test_descendants_at_distance(self):
    def test_descendants_at_distance_missing_source(self):
class TestBreadthLimitedSearch:
    def setup_class(cls):
    def test_limited_bfs_successor(self):
    def test_limited_bfs_predecessor(self):
    def test_limited_bfs_tree(self):
    def test_limited_bfs_edges(self):
    def test_limited_descendants_at_distance(self):

algorithms/shortest_paths/weighted.py
def _weight_function(G, weight):
def dijkstra_path(G, source, target, weight="weight"):
def dijkstra_path_length(G, source, target, weight="weight"):
def single_source_dijkstra_path(G, source, cutoff=None, weight="weight"):
def single_source_dijkstra_path_length(G, source, cutoff=None, weight="weight"):
def single_source_dijkstra(G, source, target=None, cutoff=None, weight="weight"):
def multi_source_dijkstra_path(G, sources, cutoff=None, weight="weight"):
def multi_source_dijkstra_path_length(G, sources, cutoff=None, weight="weight"):
def multi_source_dijkstra(G, sources, target=None, cutoff=None, weight="weight"):
def _dijkstra(G, source, weight, pred=None, paths=None, cutoff=None, target=None):
def _dijkstra_multisource(
def dijkstra_predecessor_and_distance(G, source, cutoff=None, weight="weight"):
def all_pairs_dijkstra(G, cutoff=None, weight="weight"):
def all_pairs_dijkstra_path_length(G, cutoff=None, weight="weight"):
def all_pairs_dijkstra_path(G, cutoff=None, weight="weight"):
def bellman_ford_predecessor_and_distance(
def _bellman_ford(
def _inner_bellman_ford(
def bellman_ford_path(G, source, target, weight="weight"):
def bellman_ford_path_length(G, source, target, weight="weight"):
def single_source_bellman_ford_path(G, source, weight="weight"):
def single_source_bellman_ford_path_length(G, source, weight="weight"):
def single_source_bellman_ford(G, source, target=None, weight="weight"):
def all_pairs_bellman_ford_path_length(G, weight="weight"):
def all_pairs_bellman_ford_path(G, weight="weight"):
def goldberg_radzik(G, source, weight="weight"):
    def topo_sort(relabeled):
    def relax(to_scan):
def negative_edge_cycle(G, weight="weight", heuristic=True):
def find_negative_cycle(G, source, weight="weight"):
def bidirectional_dijkstra(G, source, target, weight="weight"):
def johnson(G, weight="weight"):
    def new_weight(u, v, d):
    def dist_path(v):

algorithms/components/semiconnected.py
def is_semiconnected(G, topo_order=None):

algorithms/traversal/tests/test_edgebfs.py
class TestEdgeBFS:
    def setup_class(cls):
    def test_empty(self):
    def test_graph_single_source(self):
    def test_graph(self):
    def test_digraph(self):
    def test_digraph_orientation_invalid(self):
    def test_digraph_orientation_none(self):
    def test_digraph_orientation_original(self):
    def test_digraph2(self):
    def test_digraph_rev(self):
    def test_digraph_rev2(self):
    def test_multigraph(self):
    def test_multidigraph(self):
    def test_multidigraph_rev(self):
    def test_digraph_ignore(self):
    def test_digraph_ignore2(self):
    def test_multidigraph_ignore(self):

algorithms/components/attracting.py
def attracting_components(G):
def number_attracting_components(G):
def is_attracting_component(G):

algorithms/traversal/tests/test_dfs.py
class TestDFS:
    def setup_class(cls):
    def test_preorder_nodes(self):
    def test_postorder_nodes(self):
    def test_successor(self):
    def test_predecessor(self):
    def test_dfs_tree(self):
    def test_dfs_edges(self):
    def test_dfs_labeled_edges(self):
    def test_dfs_labeled_disconnected_edges(self):
    def test_dfs_tree_isolates(self):
class TestDepthLimitedSearch:
    def setup_class(cls):
    def test_dls_preorder_nodes(self):
    def test_dls_postorder_nodes(self):
    def test_dls_successor(self):
    def test_dls_predecessor(self):
    def test_dls_tree(self):
    def test_dls_edges(self):
    def test_dls_labeled_edges(self):
    def test_dls_labeled_disconnected_edges(self):

algorithms/traversal/tests/test_edgedfs.py
class TestEdgeDFS:
    def setup_class(cls):
    def test_empty(self):
    def test_graph(self):
    def test_digraph(self):
    def test_digraph_orientation_invalid(self):
    def test_digraph_orientation_none(self):
    def test_digraph_orientation_original(self):
    def test_digraph2(self):
    def test_digraph_rev(self):
    def test_digraph_rev2(self):
    def test_multigraph(self):
    def test_multidigraph(self):
    def test_multidigraph_rev(self):
    def test_digraph_ignore(self):
    def test_digraph_ignore2(self):
    def test_multidigraph_ignore(self):

algorithms/components/biconnected.py
def is_biconnected(G):
def biconnected_component_edges(G):
def biconnected_components(G):
def articulation_points(G):
def _biconnected_dfs(G, components=True):

algorithms/simple_paths.py
def is_simple_path(G, nodes):
def all_simple_paths(G, source, target, cutoff=None):
def _empty_generator():
def _all_simple_paths_graph(G, source, targets, cutoff):
def _all_simple_paths_multigraph(G, source, targets, cutoff):
def all_simple_edge_paths(G, source, target, cutoff=None):
def _all_simple_edge_paths_multigraph(G, source, targets, cutoff):
def shortest_simple_paths(G, source, target, weight=None):
        def length_func(path):
class PathBuffer:
    def __init__(self):
    def __len__(self):
    def push(self, cost, path):
    def pop(self):
def _bidirectional_shortest_path(
def _bidirectional_pred_succ(G, source, target, ignore_nodes=None, ignore_edges=None):
        def filter_iter(nodes):
            def iterate(v):
            def filter_pred_iter(pred_iter):
                def iterate(v):
            def filter_succ_iter(succ_iter):
                def iterate(v):
            def filter_iter(nodes):
                def iterate(v):
def _bidirectional_dijkstra(
        def filter_iter(nodes):
            def iterate(v):
            def filter_pred_iter(pred_iter):
                def iterate(v):
            def filter_succ_iter(succ_iter):
                def iterate(v):
            def filter_iter(nodes):
                def iterate(v):

algorithms/components/tests/test_weakly_connected.py
class TestWeaklyConnected:
    def setup_class(cls):
    def test_weakly_connected_components(self):
    def test_number_weakly_connected_components(self):
    def test_is_weakly_connected(self):
    def test_null_graph(self):
    def test_connected_raise(self):
    def test_connected_mutability(self):

algorithms/components/strongly_connected.py
def strongly_connected_components(G):
def kosaraju_strongly_connected_components(G, source=None):
def strongly_connected_components_recursive(G):
    def visit(v, cnt):
def number_strongly_connected_components(G):
def is_strongly_connected(G):
def condensation(G, scc=None):

algorithms/components/connected.py
def connected_components(G):
def number_connected_components(G):
def is_connected(G):
def node_connected_component(G, n):
def _plain_bfs(G, source):

algorithms/components/weakly_connected.py
def weakly_connected_components(G):
def number_weakly_connected_components(G):
def is_weakly_connected(G):
def _plain_bfs(G, source):

algorithms/components/tests/test_attracting.py
class TestAttractingComponents:
    def setup_class(cls):
    def test_attracting_components(self):
    def test_number_attacting_components(self):
    def test_is_attracting_component(self):
    def test_connected_raise(self):

algorithms/non_randomness.py
def non_randomness(G, k=None, weight="weight"):

algorithms/components/tests/test_semiconnected.py
class TestIsSemiconnected:
    def test_undirected(self):
    def test_empty(self):
    def test_single_node_graph(self):
    def test_path(self):
    def test_cycle(self):
    def test_tree(self):
    def test_dumbbell(self):
    def test_alternating_path(self):

algorithms/isolate.py
def is_isolate(G, n):
def isolates(G):
def number_of_isolates(G):

algorithms/voronoi.py
def voronoi_cells(G, center_nodes, weight="weight"):

algorithms/components/tests/test_strongly_connected.py
class TestStronglyConnected:
    def setup_class(cls):
    def test_tarjan(self):
    def test_tarjan_recursive(self):
    def test_kosaraju(self):
    def test_number_strongly_connected_components(self):
    def test_is_strongly_connected(self):
    def test_contract_scc1(self):
    def test_contract_scc_isolate(self):
    def test_contract_scc_edge(self):
    def test_condensation_mapping_and_members(self):
    def test_null_graph(self):
    def test_connected_raise(self):
    def test_connected_mutability(self, get_components):

algorithms/components/tests/test_biconnected.py
def assert_components_edges_equal(x, y):
def assert_components_equal(x, y):
def test_barbell():
def test_articulation_points_repetitions():
def test_articulation_points_cycle():
def test_is_biconnected():
def test_empty_is_biconnected():
def test_biconnected_components_cycle():
def test_biconnected_components1():
def test_biconnected_components2():
def test_biconnected_davis():
def test_biconnected_karate():
def test_biconnected_eppstein():
def test_null_graph():
def test_connected_raise():

algorithms/components/tests/test_connected.py
class TestConnected:
    def setup_class(cls):
    def test_connected_components(self):
    def test_number_connected_components(self):
    def test_number_connected_components2(self):
    def test_connected_components2(self):
    def test_node_connected_components(self):
    def test_is_connected(self):
    def test_connected_raise(self):
    def test_connected_mutability(self):

algorithms/matching.py
def maximal_matching(G):
def matching_dict_to_set(matching):
def is_matching(G, matching):
def is_maximal_matching(G, matching):
def is_perfect_matching(G, matching):
def min_weight_matching(G, maxcardinality=None, weight="weight"):
def max_weight_matching(G, maxcardinality=False, weight="weight"):
    class NoNode:
    class Blossom:
        def leaves(self):
    def slack(v, w):
    def assignLabel(w, t, v):
    def scanBlossom(v, w):
    def addBlossom(base, v, w):
    def expandBlossom(b, endstage):
    def augmentBlossom(b, v):
    def augmentMatching(v, w):
    def verifyOptimum():

algorithms/hierarchy.py
def flow_hierarchy(G, weight=None):

algorithms/node_classification/utils.py
def _get_label_info(G, label_name):

algorithms/node_classification/lgc.py
def local_and_global_consistency(G, alpha=0.99, max_iter=30, label_name="label"):

algorithms/bipartite/covering.py
def min_edge_cover(G, matching_algorithm=None):

algorithms/polynomials.py
def tutte_polynomial(G):

algorithms/threshold.py
def is_threshold_graph(G):
def is_threshold_sequence(degree_sequence):
def creation_sequence(degree_sequence, with_labels=False, compact=False):
def make_compact(creation_sequence):
def uncompact(creation_sequence):
def creation_sequence_to_weights(creation_sequence):
def weights_to_creation_sequence(
def threshold_graph(creation_sequence, create_using=None):
def find_alternating_4_cycle(G):
def find_threshold_graph(G, create_using=None):
def find_creation_sequence(G):
def triangles(creation_sequence):
def triangle_sequence(creation_sequence):
def cluster_sequence(creation_sequence):
def degree_sequence(creation_sequence):
def density(creation_sequence):
def degree_correlation(creation_sequence):
def shortest_path(creation_sequence, u, v):
def shortest_path_length(creation_sequence, i):
def betweenness_sequence(creation_sequence, normalized=True):
def eigenvectors(creation_sequence):
def spectral_projection(u, eigenpairs):
def eigenvalues(creation_sequence):
def random_threshold_sequence(n, p, seed=None):
def right_d_threshold_sequence(n, m):
def left_d_threshold_sequence(n, m):
def swap_d(cs, p_split=1.0, p_combine=1.0, seed=None):

algorithms/core.py
def core_number(G):
def find_cores(G):
def _core_subgraph(G, k_filter, k=None, core=None):
def k_core(G, k=None, core_number=None):
    def k_filter(v, k, c):
def k_shell(G, k=None, core_number=None):
    def k_filter(v, k, c):
def k_crust(G, k=None, core_number=None):
def k_corona(G, k, core_number=None):
    def func(v, k, c):
def k_truss(G, k):
def onion_layers(G):

algorithms/node_classification/__init__.py
def __getattr__(name):
def __dir__():

algorithms/node_classification/hmn.py
def harmonic_function(G, max_iter=30, label_name="label"):

algorithms/bipartite/spectral.py
def spectral_bipartivity(G, nodes=None, weight="weight"):

algorithms/bipartite/projection.py
def projected_graph(B, nodes, multigraph=False):
def weighted_projected_graph(B, nodes, ratio=False):
def collaboration_weighted_projected_graph(B, nodes):
def overlap_weighted_projected_graph(B, nodes, jaccard=True):
def generic_weighted_projected_graph(B, nodes, weight_function=None):
        def weight_function(G, u, v):
def project(B, nodes, create_using=None):

algorithms/bipartite/edgelist.py
def write_edgelist(G, path, comments="#", delimiter=" ", data=True, encoding="utf-8"):
def generate_edgelist(G, delimiter=" ", data=True):
def parse_edgelist(
def read_edgelist(

algorithms/bipartite/cluster.py
def cc_dot(nu, nv):
def cc_max(nu, nv):
def cc_min(nu, nv):
def latapy_clustering(G, nodes=None, mode="dot"):
def average_clustering(G, nodes=None, mode="dot"):
def robins_alexander_clustering(G):
def _four_cycles(G):
def _threepaths(G):

algorithms/bipartite/basic.py
def color(G):
        def neighbors(v):
def is_bipartite(G):
def is_bipartite_node_set(G, nodes):
def sets(G, top_nodes=None):
def density(B, nodes):
def degrees(B, nodes, weight=None):

algorithms/bipartite/centrality.py
def degree_centrality(G, nodes):
def betweenness_centrality(G, nodes):
def closeness_centrality(G, nodes, normalized=True):

algorithms/bipartite/tests/test_redundancy.py
def test_no_redundant_nodes():
def test_redundant_nodes():
def test_not_enough_neighbors():

algorithms/bipartite/generators.py
def complete_bipartite_graph(n1, n2, create_using=None):
def configuration_model(aseq, bseq, create_using=None, seed=None):
def havel_hakimi_graph(aseq, bseq, create_using=None):
def reverse_havel_hakimi_graph(aseq, bseq, create_using=None):
def alternating_havel_hakimi_graph(aseq, bseq, create_using=None):
def preferential_attachment_graph(aseq, p, create_using=None, seed=None):
def random_graph(n, m, p, seed=None, directed=False):
def gnmk_random_graph(n, m, k, seed=None, directed=False):
def _add_nodes_with_bipartite_label(G, lena, lenb):

algorithms/bipartite/matching.py
def hopcroft_karp_matching(G, top_nodes=None):
    def breadth_first_search():
    def depth_first_search(v):
def eppstein_matching(G, top_nodes=None):
        def recurse(v):
def _is_connected_by_alternating_path(G, v, matched_edges, unmatched_edges, targets):
    def _alternating_dfs(u, along_matched=True):
def _connected_by_alternating_paths(G, matching, targets):
def to_vertex_cover(G, matching, top_nodes=None):
def minimum_weight_full_matching(G, top_nodes=None, weight="weight"):

algorithms/bipartite/tests/test_spectral_bipartivity.py
class TestSpectralBipartivity:
    def test_star_like(self):
    def test_k23_like(self):
    def test_single_nodes(self):

algorithms/bipartite/tests/test_project.py
class TestBipartiteProject:
    def test_path_projected_graph(self):
    def test_path_projected_properties_graph(self):
    def test_path_collaboration_projected_graph(self):
    def test_directed_path_collaboration_projected_graph(self):
    def test_path_weighted_projected_graph(self):
    def test_path_weighted_projected_directed_graph(self):
    def test_star_projected_graph(self):
    def test_project_multigraph(self):
    def test_project_collaboration(self):
    def test_directed_projection(self):
class TestBipartiteWeightedProjection:
    def setup_class(cls):
    def test_project_weighted_shared(self):
    def test_project_weighted_newman(self):
    def test_project_weighted_ratio(self):
    def test_project_weighted_overlap(self):
    def test_project_weighted_jaccard(self):
    def test_generic_weighted_projected_graph_simple(self):
        def shared(G, u, v):
    def test_generic_weighted_projected_graph_custom(self):
        def jaccard(G, u, v):
        def my_weight(G, u, v, weight="weight"):

algorithms/bipartite/tests/test_matching.py
class TestMatching:
    def setup(self):
    def check_match(self, matching):
    def check_vertex_cover(self, vertices):
    def test_eppstein_matching(self):
    def test_hopcroft_karp_matching(self):
    def test_to_vertex_cover(self):
    def test_eppstein_matching_simple(self):
    def test_hopcroft_karp_matching_simple(self):
    def test_eppstein_matching_disconnected(self):
    def test_hopcroft_karp_matching_disconnected(self):
    def test_issue_2127(self):
    def test_vertex_cover_issue_2384(self):
    def test_vertex_cover_issue_3306(self):
    def test_unorderable_nodes(self):
def test_eppstein_matching():
class TestMinimumWeightFullMatching:
    def setup_class(cls):
    def test_minimum_weight_full_matching_incomplete_graph(self):
    def test_minimum_weight_full_matching_with_no_full_matching(self):
    def test_minimum_weight_full_matching_square(self):
    def test_minimum_weight_full_matching_smaller_left(self):
    def test_minimum_weight_full_matching_smaller_top_nodes_right(self):
    def test_minimum_weight_full_matching_smaller_right(self):
    def test_minimum_weight_full_matching_negative_weights(self):
    def test_minimum_weight_full_matching_different_weight_key(self):

algorithms/bipartite/tests/test_matrix.py
class TestBiadjacencyMatrix:
    def test_biadjacency_matrix_weight(self):
    def test_biadjacency_matrix(self):
    def test_biadjacency_matrix_order(self):
    def test_null_graph(self):
    def test_empty_graph(self):
    def test_duplicate_row(self):
    def test_duplicate_col(self):
    def test_format_keyword(self):
    def test_from_biadjacency_roundtrip(self):
    def test_from_biadjacency_weight(self):
    def test_from_biadjacency_multigraph(self):

algorithms/bipartite/tests/test_edgelist.py
class TestEdgelist:
    def setup_class(cls):
    def test_read_edgelist_1(self):
    def test_read_edgelist_3(self):
    def test_write_edgelist_1(self):
    def test_write_edgelist_2(self):
    def test_write_edgelist_3(self):
    def test_write_edgelist_4(self):
    def test_unicode(self):
    def test_latin1_issue(self):
    def test_latin1(self):
    def test_edgelist_graph(self):
    def test_edgelist_integers(self):
    def test_edgelist_multigraph(self):
    def test_empty_digraph(self):
    def test_raise_attribute(self):

algorithms/bipartite/tests/test_covering.py
class TestMinEdgeCover:
    def test_empty_graph(self):
    def test_graph_single_edge(self):
    def test_bipartite_default(self):
    def test_bipartite_explicit(self):

algorithms/bipartite/tests/test_generators.py
class TestGeneratorsBipartite:
    def test_complete_bipartite_graph(self):
    def test_configuration_model(self):
    def test_havel_hakimi_graph(self):
    def test_reverse_havel_hakimi_graph(self):
    def test_alternating_havel_hakimi_graph(self):
    def test_preferential_attachment(self):
    def test_random_graph(self):
    def test_random_digraph(self):
    def test_gnmk_random_graph(self):
    def test_gnmk_random_graph_complete(self):

algorithms/bipartite/tests/test_cluster.py
def test_pairwise_bipartite_cc_functions():
def test_star_graph():
def test_not_bipartite():
def test_bad_mode():
def test_path_graph():
def test_average_path_graph():
def test_ra_clustering_davis():
def test_ra_clustering_square():
def test_ra_clustering_zero():

algorithms/bipartite/redundancy.py
def node_redundancy(G, nodes=None):
def _node_redundancy(G, v):

algorithms/bipartite/tests/test_centrality.py
class TestBipartiteCentrality:
    def setup_class(cls):
    def test_degree_centrality(self):
    def test_betweenness_centrality(self):
    def test_closeness_centrality(self):
    def test_davis_degree_centrality(self):
    def test_davis_betweenness_centrality(self):
    def test_davis_closeness_centrality(self):

algorithms/bipartite/tests/test_basic.py
class TestBipartiteBasic:
    def test_is_bipartite(self):
    def test_bipartite_color(self):
    def test_not_bipartite_color(self):
    def test_bipartite_directed(self):
    def test_bipartite_sets(self):
    def test_bipartite_sets_directed(self):
    def test_bipartite_sets_given_top_nodes(self):
    def test_bipartite_sets_disconnected(self):
    def test_is_bipartite_node_set(self):
    def test_bipartite_density(self):
    def test_bipartite_degrees(self):
    def test_bipartite_weighted_degrees(self):
    def test_biadjacency_matrix_weight(self):
    def test_biadjacency_matrix(self):
    def test_biadjacency_matrix_order(self):

algorithms/bipartite/matrix.py
def biadjacency_matrix(
def from_biadjacency_matrix(A, create_using=None, edge_attribute="weight"):

algorithms/chordal.py
class NetworkXTreewidthBoundExceeded(nx.NetworkXException):
def is_chordal(G):
def find_induced_nodes(G, s, t, treewidth_bound=sys.maxsize):
def chordal_graph_cliques(G):
def chordal_graph_treewidth(G):
def _is_complete_graph(G):
def _find_missing_edge(G):
def _max_cardinality_node(G, choices, wanna_connect):
def _find_chordality_breaker(G, s=None, treewidth_bound=sys.maxsize):
def _chordal_graph_cliques(G):
def complete_to_chordal_graph(G):

algorithms/dominance.py
def immediate_dominators(G, start):
    def intersect(u, v):
def dominance_frontiers(G, start):

algorithms/communicability_alg.py
def communicability(G):
def communicability_exp(G):

algorithms/hybrid.py
def kl_connected_subgraph(G, k, l, low_memory=False, same_as_graph=False):
def is_kl_connected(G, k, l, low_memory=False):

algorithms/dag.py
def descendants(G, source):
def ancestors(G, source):
def has_cycle(G):
def is_directed_acyclic_graph(G):
def topological_generations(G):
def topological_sort(G):
def lexicographical_topological_sort(G, key=None):
        def key(node):
    def create_tuple(node):
def all_topological_sorts(G):
def is_aperiodic(G):
def transitive_closure(G, reflexive=False):
def transitive_closure_dag(G, topo_order=None):
def transitive_reduction(G):
def antichains(G, topo_order=None):
def dag_longest_path(G, weight="weight", default_weight=1, topo_order=None):
def dag_longest_path_length(G, weight="weight", default_weight=1):
def root_to_leaf_paths(G):
def dag_to_branching(G):

algorithms/tests/test_vitality.py
class TestClosenessVitality:
    def test_unweighted(self):
    def test_weighted(self):
    def test_unweighted_digraph(self):
    def test_weighted_digraph(self):
    def test_weighted_multidigraph(self):
    def test_disconnecting_graph(self):

algorithms/tests/test_d_separation.py
def path_graph():
def fork_graph():
def collider_graph():
def naive_bayes_graph():
def asia_graph():
def path_graph_fixture():
def fork_graph_fixture():
def collider_graph_fixture():
def naive_bayes_graph_fixture():
def asia_graph_fixture():
def test_markov_condition(graph):
def test_path_graph_dsep(path_graph):
def test_fork_graph_dsep(fork_graph):
def test_collider_graph_dsep(collider_graph):
def test_naive_bayes_dsep(naive_bayes_graph):
def test_asia_graph_dsep(asia_graph):
def test_undirected_graphs_are_not_supported():
def test_cyclic_graphs_raise_error():
def test_invalid_nodes_raise_error(asia_graph):

algorithms/swap.py
def double_edge_swap(G, nswap=1, max_tries=100, seed=None):
def connected_double_edge_swap(G, nswap=1, _window_threshold=3, seed=None):

algorithms/tests/test_richclub.py
def test_richclub():
def test_richclub_seed():
def test_richclub_normalized():
def test_richclub2():
def test_richclub3():
def test_richclub4():
def test_richclub_exception():
def test_rich_club_exception2():

algorithms/tests/test_mis.py
class TestMaximalIndependantSet:
    def setup(self):
    def test_random_seed(self):
    def test_K5(self):
    def test_K55(self):
    def test_exception(self):
    def test_digraph_exception(self):
    def test_florentine_family(self):
    def test_bipartite(self):
    def test_random_graphs(self):

algorithms/centrality/flow_matrix.py
def flow_matrix_row(G, weight=None, dtype=float, solver="lu"):
class InverseLaplacian:
    def __init__(self, L, width=None, dtype=None):
    def init_solver(self, L):
    def solve(self, r):
    def solve_inverse(self, r):
    def get_rows(self, r1, r2):
    def get_row(self, r):
    def width(self, L):
class FullInverseLaplacian(InverseLaplacian):
    def init_solver(self, L):
    def solve(self, rhs):
    def solve_inverse(self, r):
class SuperLUInverseLaplacian(InverseLaplacian):
    def init_solver(self, L):
    def solve_inverse(self, r):
    def solve(self, rhs):
class CGInverseLaplacian(InverseLaplacian):
    def init_solver(self, L):
    def solve(self, rhs):
    def solve_inverse(self, r):

algorithms/tests/test_smallworld.py
def test_random_reference():
def test_lattice_reference():
def test_sigma():
def test_omega():

algorithms/tests/test_structuralholes.py
class TestStructuralHoles:
    def setup(self):
    def test_constraint_directed(self):
    def test_effective_size_directed(self):
    def test_constraint_weighted_directed(self):
    def test_effective_size_weighted_directed(self):
    def test_constraint_undirected(self):
    def test_effective_size_undirected_borgatti(self):
    def test_effective_size_undirected(self):
    def test_constraint_weighted_undirected(self):
    def test_effective_size_weighted_undirected(self):
    def test_constraint_isolated(self):
    def test_effective_size_isolated(self):
    def test_effective_size_borgatti_isolated(self):

algorithms/tests/test_dominating.py
def test_dominating_set():
def test_complete():
def test_raise_dominating_set():
def test_is_dominating_set():
def test_wikipedia_is_dominating_set():

algorithms/tests/test_dominance.py
class TestImmediateDominators:
    def test_exceptions(self):
    def test_singleton(self):
    def test_path(self):
    def test_cycle(self):
    def test_unreachable(self):
    def test_irreducible1(self):
    def test_irreducible2(self):
    def test_domrel_png(self):
    def test_boost_example(self):
class TestDominanceFrontiers:
    def test_exceptions(self):
    def test_singleton(self):
    def test_path(self):
    def test_cycle(self):
    def test_unreachable(self):
    def test_irreducible1(self):
    def test_irreducible2(self):
    def test_domrel_png(self):
    def test_boost_example(self):
    def test_discard_issue(self):
    def test_loop(self):
    def test_missing_immediate_doms(self):
    def test_loops_larger(self):

algorithms/tests/test_similarity.py
def nmatch(n1, n2):
def ematch(e1, e2):
def getCanonical():
class TestSimilarity:
    def setup_class(cls):
    def test_graph_edit_distance_roots_and_timeout(self):
    def test_graph_edit_distance(self):
    def test_graph_edit_distance_node_match(self):
    def test_graph_edit_distance_edge_match(self):
    def test_graph_edit_distance_node_cost(self):
        def node_subst_cost(uattr, vattr):
        def node_del_cost(attr):
        def node_ins_cost(attr):
    def test_graph_edit_distance_edge_cost(self):
        def edge_subst_cost(gattr, hattr):
        def edge_del_cost(attr):
        def edge_ins_cost(attr):
    def test_graph_edit_distance_upper_bound(self):
    def test_optimal_edit_paths(self):
        def canonical(vertex_path, edge_path):
    def test_optimize_graph_edit_distance(self):
    def test_selfloops(self):
    def test_digraph(self):
    def test_multigraph(self):
    def test_multidigraph(self):
    def testCopy(self):
    def testSame(self):
    def testOneEdgeLabelDiff(self):
    def testOneNodeLabelDiff(self):
    def testOneExtraNode(self):
    def testOneExtraEdge(self):
    def testOneExtraNodeAndEdge(self):
    def testGraph1(self):
    def testGraph2(self):
    def testGraph3(self):
    def testGraph4(self):
    def testGraph4_a(self):
    def testGraph4_b(self):
    def test_simrank_no_source_no_target(self, simrank_similarity):
    def test_simrank_source_no_target(self, simrank_similarity):
    def test_simrank_noninteger_nodes(self, simrank_similarity):
    def test_simrank_source_and_target(self, simrank_similarity):
    def test_simrank_max_iterations(self, alg):
    def test_simrank_between_versions(self):
    def test_simrank_numpy_no_source_no_target(self):
    def test_simrank_numpy_source_no_target(self):
    def test_simrank_numpy_source_and_target(self):
    def test_panther_similarity_unweighted(self):
    def test_panther_similarity_weighted(self):
    def test_generate_random_paths_unweighted(self):
    def test_generate_random_paths_weighted(self):
    def test_symmetry_with_custom_matching(self):

algorithms/centrality/dispersion.py
def dispersion(G, u=None, v=None, normalized=True, alpha=1.0, b=0.0, c=0.0):
    def _dispersion(G_u, u, v):

algorithms/tests/test_reciprocity.py
class TestReciprocity:
    def test_reciprocity_digraph(self):
    def test_overall_reciprocity_empty_graph(self):
    def test_reciprocity_graph_nodes(self):
    def test_reciprocity_graph_node(self):
    def test_reciprocity_graph_isolated_nodes(self):

algorithms/tests/test_efficiency.py
class TestEfficiency:
    def setup_method(self):
    def test_efficiency_disconnected_nodes(self):
    def test_local_efficiency_disconnected_graph(self):
    def test_efficiency(self):
    def test_global_efficiency(self):
    def test_global_efficiency_complete_graph(self):
    def test_local_efficiency_complete_graph(self):
    def test_using_ego_graph(self):

algorithms/centrality/degree_alg.py
def degree_centrality(G):
def in_degree_centrality(G):
def out_degree_centrality(G):

algorithms/centrality/harmonic.py
def harmonic_centrality(G, nbunch=None, distance=None, sources=None):

algorithms/centrality/trophic.py
def trophic_levels(G, weight="weight"):
def trophic_differences(G, weight="weight"):
def trophic_incoherence_parameter(G, weight="weight", cannibalism=False):

algorithms/centrality/subgraph_alg.py
def subgraph_centrality_exp(G):
def subgraph_centrality(G):
def communicability_betweenness_centrality(G):
def estrada_index(G):

algorithms/tests/test_cuts.py
class TestCutSize:
    def test_symmetric(self):
    def test_single_edge(self):
    def test_directed(self):
    def test_directed_symmetric(self):
    def test_multigraph(self):
class TestVolume:
    def test_graph(self):
    def test_digraph(self):
    def test_multigraph(self):
    def test_multidigraph(self):
    def test_barbell(self):
class TestNormalizedCutSize:
    def test_graph(self):
    def test_directed(self):
class TestConductance:
    def test_graph(self):
class TestEdgeExpansion:
    def test_graph(self):
class TestNodeExpansion:
    def test_graph(self):
class TestBoundaryExpansion:
    def test_graph(self):
class TestMixingExpansion:
    def test_graph(self):

algorithms/tests/test_hybrid.py
def test_2d_grid_graph():
def test_small_graph():

algorithms/tests/test_hierarchy.py
def test_hierarchy_exception():
def test_hierarchy_cycle():
def test_hierarchy_tree():
def test_hierarchy_1():
def test_hierarchy_weight():

algorithms/tests/test_moral.py
def test_get_moral_graph():

algorithms/centrality/load.py
def newman_betweenness_centrality(G, v=None, cutoff=None, normalized=True, weight=None):
def _node_betweenness(G, source, cutoff=False, normalized=True, weight=None):
def edge_load_centrality(G, cutoff=False):
def _edge_betweenness(G, source, nodes=None, cutoff=False):

algorithms/tests/test_clique.py
class TestCliques:
    def setup_method(self):
    def test_find_cliques1(self):
    def test_selfloops(self):
    def test_find_cliques2(self):
    def test_find_cliques3(self):
    def test_clique_number(self):
    def test_clique_number2(self):
    def test_clique_number3(self):
    def test_number_of_cliques(self):
    def test_node_clique_number(self):
    def test_cliques_containing_node(self):
    def test_make_clique_bipartite(self):
    def test_make_max_clique_graph(self):
    def test_directed(self):
class TestEnumerateAllCliques:
    def test_paper_figure_4(self):

algorithms/centrality/betweenness.py
def betweenness_centrality(
def edge_betweenness_centrality(G, k=None, normalized=True, weight=None, seed=None):
def edge_betweenness(G, k=None, normalized=True, weight=None, seed=None):
def _single_source_shortest_path_basic(G, s):
def _single_source_dijkstra_path_basic(G, s, weight):
def _accumulate_basic(betweenness, S, P, sigma, s):
def _accumulate_endpoints(betweenness, S, P, sigma, s):
def _accumulate_edges(betweenness, S, P, sigma, s):
def _rescale(betweenness, n, normalized, directed=False, k=None, endpoints=False):
def _rescale_e(betweenness, n, normalized, directed=False, k=None):
def _add_edge_keys(G, betweenness, weight=None):

algorithms/centrality/group.py
def group_betweenness_centrality(G, C, normalized=True, weight=None, endpoints=False):
def _group_preprocessing(G, set_v, weight):
def prominent_group(
def _dfbnb(G, k, DF_tree, max_GBC, root, D, max_group, nodes, greedy):
def _heuristic(k, root, DF_tree, D, nodes, greedy):
def group_closeness_centrality(G, S, weight=None):
def group_degree_centrality(G, S):
def group_in_degree_centrality(G, S):
def group_out_degree_centrality(G, S):

algorithms/tests/test_covering.py
class TestMinEdgeCover:
    def test_empty_graph(self):
    def test_graph_with_loop(self):
    def test_graph_single_edge(self):
    def test_graph_two_edge_path(self):
    def test_bipartite_explicit(self):
    def test_complete_graph_even(self):
    def test_complete_graph_odd(self):
class TestIsEdgeCover:
    def test_empty_graph(self):
    def test_graph_with_loop(self):
    def test_graph_single_edge(self):

algorithms/tests/test_distance_regular.py
class TestDistanceRegular:
    def test_is_distance_regular(self):
    def test_not_connected(self):
    def test_global_parameters(self):
    def test_intersection_array(self):
class TestStronglyRegular:
    def test_cycle_graph(self):
    def test_petersen_graph(self):
    def test_path_graph(self):

algorithms/tests/test_matching.py
class TestMaxWeightMatching:
    def test_trivial1(self):
    def test_selfloop(self):
    def test_single_edge(self):
    def test_two_path(self):
    def test_path(self):
    def test_square(self):
    def test_edge_attribute_name(self):
    def test_floating_point_weights(self):
    def test_negative_weights(self):
    def test_s_blossom(self):
    def test_s_t_blossom(self):
    def test_nested_s_blossom(self):
    def test_nested_s_blossom_relabel(self):
    def test_nested_s_blossom_expand(self):
    def test_s_blossom_relabel_expand(self):
    def test_nested_s_blossom_relabel_expand(self):
    def test_nasty_blossom1(self):
    def test_nasty_blossom2(self):
    def test_nasty_blossom_least_slack(self):
    def test_nasty_blossom_augmenting(self):
    def test_nasty_blossom_expand_recursively(self):
    def test_wrong_graph_type(self):
class TestIsMatching:
    def test_dict(self):
    def test_empty_matching(self):
    def test_single_edge(self):
    def test_edge_order(self):
    def test_valid_matching(self):
    def test_invalid_input(self):
    def test_selfloops(self):
    def test_invalid_matching(self):
    def test_invalid_edge(self):
class TestIsMaximalMatching:
    def test_dict(self):
    def test_valid(self):
    def test_not_matching(self):
    def test_not_maximal(self):
class TestIsPerfectMatching:
    def test_dict(self):
    def test_valid(self):
    def test_valid_not_path(self):
    def test_not_matching(self):
    def test_maximal_but_not_perfect(self):
class TestMaximalMatching:
    def test_valid_matching(self):
    def test_single_edge_matching(self):
    def test_self_loops(self):
    def test_ordering(self):
    def test_wrong_graph_type(self):

algorithms/centrality/katz.py
def katz_centrality(
def katz_centrality_numpy(G, alpha=0.1, beta=1.0, normalized=True, weight=None):

algorithms/centrality/current_flow_betweenness.py
def approximate_current_flow_betweenness_centrality(
def current_flow_betweenness_centrality(
def edge_current_flow_betweenness_centrality(

algorithms/tests/test_cluster.py
class TestTriangles:
    def test_empty(self):
    def test_path(self):
    def test_cubical(self):
    def test_k5(self):
class TestDirectedClustering:
    def test_clustering(self):
    def test_path(self):
    def test_k5(self):
    def test_triangle_and_edge(self):
class TestDirectedWeightedClustering:
    def setup_class(cls):
    def test_clustering(self):
    def test_path(self):
    def test_k5(self):
    def test_triangle_and_edge(self):
class TestWeightedClustering:
    def setup_class(cls):
    def test_clustering(self):
    def test_path(self):
    def test_cubical(self):
    def test_k5(self):
    def test_triangle_and_edge(self):
    def test_triangle_and_signed_edge(self):
class TestClustering:
    def setup_class(cls):
    def test_clustering(self):
    def test_path(self):
    def test_cubical(self):
    def test_k5(self):
    def test_k5_signed(self):
class TestTransitivity:
    def test_transitivity(self):
    def test_path(self):
    def test_cubical(self):
    def test_k5(self):
class TestSquareClustering:
    def test_clustering(self):
    def test_path(self):
    def test_cubical(self):
    def test_k5(self):
    def test_bipartite_k5(self):
    def test_lind_square_clustering(self):
    def test_peng_square_clustering(self):
class TestAverageClustering:
    def setup_class(cls):
    def test_average_clustering(self):
    def test_average_clustering_signed(self):
class TestGeneralizedDegree:
    def test_generalized_degree(self):
    def test_path(self):
    def test_cubical(self):
    def test_k5(self):

algorithms/tests/test_communicability.py
class TestCommunicability:
    def test_communicability(self):
    def test_communicability2(self):

algorithms/tests/test_isolate.py
def test_is_isolate():
def test_isolates():
def test_number_of_isolates():

algorithms/centrality/betweenness_subset.py
def betweenness_centrality_subset(G, sources, targets, normalized=False, weight=None):
def edge_betweenness_centrality_subset(
def betweenness_centrality_source(G, normalized=True, weight=None, sources=None):
def _accumulate_subset(betweenness, S, P, sigma, s, targets):
def _accumulate_edges_subset(betweenness, S, P, sigma, s, targets):
def _rescale(betweenness, n, normalized, directed=False):
def _rescale_e(betweenness, n, normalized, directed=False):

algorithms/centrality/closeness.py
def closeness_centrality(G, u=None, distance=None, wf_improved=True):
def incremental_closeness_centrality(

algorithms/tests/test_voronoi.py
class TestVoronoiCells:
    def test_isolates(self):
    def test_undirected_unweighted(self):
    def test_directed_unweighted(self):
    def test_directed_inward(self):
    def test_undirected_weighted(self):
    def test_directed_weighted(self):
    def test_multigraph_unweighted(self):
    def test_multidigraph_unweighted(self):
    def test_multigraph_weighted(self):
    def test_multidigraph_weighted(self):

algorithms/tests/test_planarity.py
class TestLRPlanarity:
    def check_graph(G, is_planar=None):
    def test_simple_planar_graph(self):
    def test_planar_with_selfloop(self):
    def test_k3_3(self):
    def test_k5(self):
    def test_multiple_components_planar(self):
    def test_multiple_components_non_planar(self):
    def test_non_planar_with_selfloop(self):
    def test_non_planar1(self):
    def test_loop(self):
    def test_comp(self):
    def test_goldner_harary(self):
    def test_planar_multigraph(self):
    def test_non_planar_multigraph(self):
    def test_planar_digraph(self):
    def test_non_planar_digraph(self):
    def test_single_component(self):
    def test_graph1(self):
    def test_graph2(self):
    def test_graph3(self):
    def test_counterexample_planar(self):
    def test_counterexample_planar_recursive(self):
def check_embedding(G, embedding):
def check_counterexample(G, sub_graph):
class TestPlanarEmbeddingClass:
    def test_get_data(self):
    def test_missing_edge_orientation(self):
    def test_invalid_edge_orientation(self):
    def test_missing_half_edge(self):
    def test_not_fulfilling_euler_formula(self):
    def test_missing_reference(self):
    def test_connect_components(self):
    def test_successful_face_traversal(self):
    def test_unsuccessful_face_traversal(self):
    def get_star_embedding(n):

algorithms/centrality/second_order.py
def second_order_centrality(G):
    def _Qj(P, j):

algorithms/centrality/voterank_alg.py
def voterank(G, number_of_nodes=None):

algorithms/tests/test_chains.py
def cycles(seq):
def cyclic_equals(seq1, seq2):
class TestChainDecomposition:
    def assertContainsChain(self, chain, expected):
    def test_decomposition(self):
    def test_barbell_graph(self):
    def test_disconnected_graph(self):
    def test_disconnected_graph_root_node(self):

algorithms/centrality/current_flow_betweenness_subset.py
def current_flow_betweenness_centrality_subset(
def edge_current_flow_betweenness_centrality_subset(

algorithms/tests/test_wiener.py
class TestWienerIndex:
    def test_disconnected_graph(self):
    def test_directed(self):
    def test_complete_graph(self):
    def test_path_graph(self):

algorithms/tests/test_graph_hashing.py
def test_empty_graph_hash():
def test_directed():
def test_reversed():
def test_isomorphic():
def test_isomorphic_edge_attr():
def test_missing_edge_attr():
def test_isomorphic_node_attr():
def test_missing_node_attr():
def test_isomorphic_edge_attr_and_node_attr():
def test_digest_size():
def is_subiteration(a, b):
def hexdigest_sizes_correct(a, digest_size):
def test_empty_graph_subgraph_hash():
def test_directed_subgraph_hash():
def test_reversed_subgraph_hash():
def test_isomorphic_subgraph_hash():
def test_isomorphic_edge_attr_subgraph_hash():
def test_missing_edge_attr_subgraph_hash():
def test_isomorphic_node_attr_subgraph_hash():
def test_missing_node_attr_subgraph_hash():
def test_isomorphic_edge_attr_and_node_attr_subgraph_hash():
def test_iteration_depth():
def test_iteration_depth_edge_attr():
def test_iteration_depth_node_attr():
def test_iteration_depth_node_edge_attr():
def test_digest_size_subgraph_hash():

algorithms/tests/test_graphical.py
def test_valid_degree_sequence1():
def test_valid_degree_sequence2():
def test_string_input():
def test_non_integer_input():
def test_negative_input():
class TestAtlas:
    def setup_class(cls):
    def test_atlas(self):
def test_small_graph_true():
def test_small_graph_false():
def test_directed_degree_sequence():
def test_small_directed_sequences():
def test_multi_sequence():
def test_pseudo_sequence():
def test_numpy_degree_sequence():

algorithms/tests/test_summarization.py
class TestDirectedDedensification:
    def build_original_graph(self):
    def build_compressed_graph(self):
    def test_empty(self):
    def densify(G, compressor_nodes, copy=True):
    def setup_method(self):
    def test_dedensify_edges(self):
    def test_dedensify_edge_count(self):
    def test_densify_edges(self):
    def test_densify_edge_count(self):
class TestUnDirectedDedensification:
    def build_original_graph(self):
    def test_empty(self):
    def setup_method(self):
    def build_compressed_graph(self):
    def test_dedensify_edges(self):
    def test_dedensify_edge_count(self):
def test_summarization_empty(graph_type):
class AbstractSNAP:
    def build_original_graph(self):
    def build_summary_graph(self):
    def test_summary_graph(self):
    def deterministic_labels(self, G):
class TestSNAPNoEdgeTypes(AbstractSNAP):
    def test_summary_graph(self):
    def build_original_graph(self):
    def build_summary_graph(self):
class TestSNAPUndirected(AbstractSNAP):
    def build_original_graph(self):
    def build_summary_graph(self):
class TestSNAPDirected(AbstractSNAP):
    def build_original_graph(self):
    def build_summary_graph(self):
class TestSNAPUndirectedMulti(AbstractSNAP):
    def build_original_graph(self):
    def build_summary_graph(self):
class TestSNAPDirectedMulti(AbstractSNAP):
    def build_original_graph(self):
    def build_summary_graph(self):

algorithms/centrality/tests/test_harmonic_centrality.py
class TestClosenessCentrality:
    def setup_class(cls):
    def test_p3_harmonic(self):
    def test_p4_harmonic(self):
    def test_clique_complete(self):
    def test_cycle_C4(self):
    def test_cycle_C5(self):
    def test_bal_tree(self):
    def test_exampleGraph(self):
    def test_weighted_harmonic(self):
    def test_empty(self):
    def test_singleton(self):
    def test_cycle_c4_directed(self):
    def test_p3_harmonic_subset(self):
    def test_p4_harmonic_subset(self):

algorithms/centrality/tests/test_percolation_centrality.py
def example1a_G():
def example1b_G():
class TestPercolationCentrality:
    def test_percolation_example1a(self):
    def test_percolation_example1b(self):
    def test_converge_to_betweenness(self):

algorithms/centrality/tests/test_degree_centrality.py
class TestDegreeCentrality:
    def setup_method(self):
    def test_degree_centrality_1(self):
    def test_degree_centrality_2(self):
    def test_degree_centrality_3(self):
    def test_degree_centrality_4(self):
    def test_indegree_centrality(self):
    def test_outdegree_centrality(self):
    def test_small_graph_centrality(self):

algorithms/centrality/tests/test_voterank.py
class TestVoteRankCentrality:
    def test_voterank_centrality_1(self):
    def test_voterank_centrality_2(self):
    def test_voterank_centrality_3(self):
    def test_voterank_centrality_4(self):
    def test_voterank_centrality_5(self):

algorithms/centrality/eigenvector.py
def eigenvector_centrality(G, max_iter=100, tol=1.0e-6, nstart=None, weight=None):
def eigenvector_centrality_numpy(G, weight=None, max_iter=50, tol=0):

algorithms/centrality/tests/test_current_flow_closeness.py
class TestFlowClosenessCentrality:
    def test_K4(self):
    def test_P4(self):
    def test_star(self):
class TestWeightedFlowClosenessCentrality:

algorithms/centrality/tests/test_current_flow_betweenness_centrality.py
class TestFlowBetweennessCentrality:
    def test_K4_normalized(self):
    def test_K4(self):
    def test_P4_normalized(self):
    def test_P4(self):
    def test_star(self):
    def test_solvers2(self):
class TestApproximateFlowBetweennessCentrality:
    def test_K4_normalized(self):
    def test_K4(self):
    def test_star(self):
    def test_grid(self):
    def test_seed(self):
    def test_solvers(self):
class TestWeightedFlowBetweennessCentrality:
class TestEdgeFlowBetweennessCentrality:
    def test_K4(self):
    def test_K4_normalized(self):
    def test_C4(self):
    def test_P4(self):

algorithms/centrality/tests/test_load_centrality.py
class TestLoadCentrality:
    def setup_class(cls):
    def test_not_strongly_connected(self):
    def test_weighted_load(self):
    def test_k5_load(self):
    def test_p3_load(self):
    def test_p2_load(self):
    def test_krackhardt_load(self):
    def test_florentine_families_load(self):
    def test_les_miserables_load(self):
    def test_unnormalized_k5_load(self):
    def test_unnormalized_p3_load(self):
    def test_unnormalized_krackhardt_load(self):
    def test_unnormalized_florentine_families_load(self):
    def test_load_betweenness_difference(self):
    def test_c4_edge_load(self):
    def test_p4_edge_load(self):
    def test_k5_edge_load(self):
    def test_tree_edge_load(self):

algorithms/centrality/tests/test_closeness_centrality.py
class TestClosenessCentrality:
    def setup_class(cls):
    def test_wf_improved(self):
    def test_digraph(self):
    def test_k5_closeness(self):
    def test_p3_closeness(self):
    def test_krackhardt_closeness(self):
    def test_florentine_families_closeness(self):
    def test_les_miserables_closeness(self):
    def test_weighted_closeness(self):
    def pick_add_edge(g):
    def pick_remove_edge(g):
    def test_directed_raises(self):
    def test_wrong_size_prev_cc_raises(self):
    def test_wrong_nodes_prev_cc_raises(self):
    def test_zero_centrality(self):
    def test_incremental(self):

algorithms/centrality/tests/test_trophic.py
def test_trophic_levels():
def test_trophic_levels_levine():
def test_trophic_levels_simple():
def test_trophic_levels_more_complex():
def test_trophic_levels_even_more_complex():
def test_trophic_levels_singular_matrix():
def test_trophic_levels_singular_with_basal():
def test_trophic_differences():
def test_trophic_incoherence_parameter_no_cannibalism():
def test_trophic_incoherence_parameter_cannibalism():

algorithms/centrality/tests/test_subgraph.py
class TestSubgraph:
    def test_subgraph_centrality(self):
    def test_subgraph_centrality_big_graph(self):
    def test_communicability_betweenness_centrality_small(self):
    def test_communicability_betweenness_centrality(self):
    def test_estrada_index(self):

algorithms/centrality/tests/test_eigenvector_centrality.py
class TestEigenvectorCentrality:
    def test_K5(self):
    def test_P3(self):
    def test_P3_unweighted(self):
    def test_maxiter(self):
class TestEigenvectorCentralityDirected:
    def setup_class(cls):
    def test_eigenvector_centrality_weighted(self):
    def test_eigenvector_centrality_weighted_numpy(self):
    def test_eigenvector_centrality_unweighted(self):
    def test_eigenvector_centrality_unweighted_numpy(self):
class TestEigenvectorCentralityExceptions:
    def test_multigraph(self):
    def test_multigraph_numpy(self):
    def test_empty(self):
    def test_empty_numpy(self):

algorithms/centrality/tests/test_reaching.py
class TestGlobalReachingCentrality:
    def test_non_positive_weights(self):
    def test_negatively_weighted(self):
    def test_directed_star(self):
    def test_undirected_unweighted_star(self):
    def test_undirected_weighted_star(self):
    def test_cycle_directed_unweighted(self):
    def test_cycle_undirected_unweighted(self):
    def test_cycle_directed_weighted(self):
    def test_cycle_undirected_weighted(self):
    def test_directed_weighted(self):
class TestLocalReachingCentrality:
    def test_non_positive_weights(self):
    def test_negatively_weighted(self):
    def test_undirected_unweighted_star(self):
    def test_undirected_weighted_star(self):

algorithms/centrality/tests/test_second_order_centrality.py
class TestSecondOrderCentrality:
    def test_empty(self):
    def test_non_connected(self):
    def test_non_negative_edge_weights(self):
    def test_one_node_graph(self):
    def test_P3(self):
    def test_K3(self):
    def test_ring_graph(self):

algorithms/centrality/tests/test_current_flow_betweenness_centrality_subset.py
class TestFlowBetweennessCentrality:
    def test_K4_normalized(self):
    def test_K4(self):
    def test_P4_normalized(self):
    def test_P4(self):
    def test_star(self):
class TestEdgeFlowBetweennessCentrality:
    def test_K4_normalized(self):
    def test_K4(self):
    def test_C4(self):
    def test_P4(self):

algorithms/centrality/tests/test_group.py
class TestGroupBetweennessCentrality:
    def test_group_betweenness_single_node(self):
    def test_group_betweenness_with_endpoints(self):
    def test_group_betweenness_normalized(self):
    def test_two_group_betweenness_value_zero(self):
    def test_group_betweenness_value_zero(self):
    def test_group_betweenness_disconnected_graph(self):
    def test_group_betweenness_node_not_in_graph(self):
    def test_group_betweenness_directed_weighted(self):
class TestProminentGroup:
    def test_prominent_group_single_node(self):
    def test_prominent_group_with_c(self):
    def test_prominent_group_normalized_endpoints(self):
    def test_prominent_group_disconnected_graph(self):
    def test_prominent_group_node_not_in_graph(self):
    def test_group_betweenness_directed_weighted(self):
    def test_prominent_group_greedy_algorithm(self):
class TestGroupClosenessCentrality:
    def test_group_closeness_single_node(self):
    def test_group_closeness_disconnected(self):
    def test_group_closeness_multiple_node(self):
    def test_group_closeness_node_not_in_graph(self):
class TestGroupDegreeCentrality:
    def test_group_degree_centrality_single_node(self):
    def test_group_degree_centrality_multiple_node(self):
    def test_group_in_degree_centrality(self):
    def test_group_out_degree_centrality(self):
    def test_group_degree_centrality_node_not_in_graph(self):

algorithms/centrality/tests/test_betweenness_centrality_subset.py
class TestSubsetBetweennessCentrality:
    def test_K5(self):
    def test_P5_directed(self):
    def test_P5(self):
    def test_P5_multiple_target(self):
    def test_box(self):
    def test_box_and_path(self):
    def test_box_and_path2(self):
    def test_diamond_multi_path(self):
class TestBetweennessCentralitySources:
    def test_K5(self):
    def test_P3(self):
class TestEdgeSubsetBetweennessCentrality:
    def test_K5(self):
    def test_P5_directed(self):
    def test_P5(self):
    def test_P5_multiple_target(self):
    def test_box(self):
    def test_box_and_path(self):
    def test_box_and_path2(self):

algorithms/centrality/tests/test_dispersion.py
def small_ego_G():
class TestDispersion:
    def test_article(self):
    def test_results_length(self):
    def test_impossible_things(self):

algorithms/centrality/tests/test_betweenness_centrality.py
def weighted_G():
class TestBetweennessCentrality:
    def test_K5(self):
    def test_K5_endpoints(self):
    def test_P3_normalized(self):
    def test_P3(self):
    def test_sample_from_P3(self):
    def test_P3_endpoints(self):
    def test_krackhardt_kite_graph(self):
    def test_krackhardt_kite_graph_normalized(self):
    def test_florentine_families_graph(self):
    def test_les_miserables_graph(self):
    def test_ladder_graph(self):
    def test_disconnected_path(self):
    def test_disconnected_path_endpoints(self):
    def test_directed_path(self):
    def test_directed_path_normalized(self):
class TestWeightedBetweennessCentrality:
    def test_K5(self):
    def test_P3_normalized(self):
    def test_P3(self):
    def test_krackhardt_kite_graph(self):
    def test_krackhardt_kite_graph_normalized(self):
    def test_florentine_families_graph(self):
    def test_les_miserables_graph(self):
    def test_ladder_graph(self):
    def test_G(self):
    def test_G2(self):
    def test_G3(self):
    def test_G4(self):
class TestEdgeBetweennessCentrality:
    def test_K5(self):
    def test_normalized_K5(self):
    def test_C4(self):
    def test_P4(self):
    def test_normalized_P4(self):
    def test_balanced_tree(self):
class TestWeightedEdgeBetweennessCentrality:
    def test_K5(self):
    def test_C4(self):
    def test_P4(self):
    def test_balanced_tree(self):
    def test_weighted_graph(self):
    def test_normalized_weighted_graph(self):
    def test_weighted_multigraph(self):
    def test_normalized_weighted_multigraph(self):

algorithms/centrality/percolation.py
def percolation_centrality(G, attribute="percolation", states=None, weight=None):
def _accumulate_percolation(percolation, G, S, P, sigma, s, states, p_sigma_x_t):

algorithms/centrality/tests/test_katz_centrality.py
class TestKatzCentrality:
    def test_K5(self):
    def test_P3(self):
    def test_maxiter(self):
    def test_beta_as_scalar(self):
    def test_beta_as_dict(self):
    def test_multiple_alpha(self):
    def test_multigraph(self):
    def test_empty(self):
    def test_bad_beta(self):
    def test_bad_beta_numbe(self):
class TestKatzCentralityNumpy:
    def setup_class(cls):
    def test_K5(self):
    def test_P3(self):
    def test_beta_as_scalar(self):
    def test_beta_as_dict(self):
    def test_multiple_alpha(self):
    def test_multigraph(self):
    def test_empty(self):
    def test_bad_beta(self):
    def test_bad_beta_numbe(self):
    def test_K5_unweighted(self):
    def test_P3_unweighted(self):
class TestKatzCentralityDirected:
    def setup_class(cls):
    def test_katz_centrality_weighted(self):
    def test_katz_centrality_unweighted(self):
class TestKatzCentralityDirectedNumpy(TestKatzCentralityDirected):
    def setup_class(cls):
    def test_katz_centrality_weighted(self):
    def test_katz_centrality_unweighted(self):
class TestKatzEigenvectorVKatz:
    def setup_class(cls):
    def test_eigenvector_v_katz_random(self):

algorithms/tests/test_distance_measures.py
def test_extrema_bounding_deprecated(compute):
def test__extrema_bounding_invalid_compute_kwarg():
class TestDistance:
    def setup_method(self):
    def test_eccentricity(self):
    def test_diameter(self):
    def test_radius(self):
    def test_periphery(self):
    def test_center(self):
    def test_bound_diameter(self):
    def test_bound_radius(self):
    def test_bound_periphery(self):
    def test_bound_center(self):
    def test_radius_exception(self):
    def test_eccentricity_infinite(self):
    def test_eccentricity_undirected_not_connected(self):
    def test_eccentricity_directed_weakly_connected(self):
class TestResistanceDistance:
    def setup_class(cls):
    def setup_method(self):
    def test_resistance_distance(self):
    def test_resistance_distance_noinv(self):
    def test_resistance_distance_no_weight(self):
    def test_resistance_distance_neg_weight(self):
    def test_multigraph(self):
    def test_resistance_distance_div0(self):
    def test_resistance_distance_not_connected(self):
    def test_resistance_distance_same_node(self):
    def test_resistance_distance_nodeA_not_in_graph(self):
    def test_resistance_distance_nodeB_not_in_graph(self):
class TestBarycenter:
    def barycenter_as_subgraph(self, g, **kwargs):
    def test_must_be_connected(self):
    def test_sp_kwarg(self):
    def test_trees(self):
    def test_this_one_specific_tree(self):

algorithms/tests/test_euler.py
class TestIsEulerian:
    def test_is_eulerian(self):
    def test_is_eulerian2(self):
class TestEulerianCircuit:
    def test_eulerian_circuit_cycle(self):
    def test_eulerian_circuit_digraph(self):
    def test_multigraph(self):
    def test_multigraph_with_keys(self):
    def test_not_eulerian(self):
class TestIsSemiEulerian:
    def test_is_semieulerian(self):
class TestHasEulerianPath:
    def test_has_eulerian_path_cyclic(self):
    def test_has_eulerian_path_non_cyclic(self):
    def test_has_eulerian_path_directed_graph(self):
    def test_has_eulerian_path_isolated_node(self):
    def test_has_eulerian_path_not_weakly_connected(self, G):
    def test_has_eulerian_path_unbalancedins_more_than_one(self, G):
class TestFindPathStart:
    def testfind_path_start(self):
class TestEulerianPath:
    def test_eulerian_path(self):
    def test_eulerian_path_straight_link(self):
    def test_eulerian_path_multigraph(self):
    def test_eulerian_path_eulerian_circuit(self):
    def test_eulerian_path_undirected(self):
    def test_eulerian_path_multigraph_undirected(self):
class TestEulerize:
    def test_disconnected(self):
    def test_null_graph(self):
    def test_null_multigraph(self):
    def test_on_empty_graph(self):
    def test_on_eulerian(self):
    def test_on_eulerian_multigraph(self):
    def test_on_complete_graph(self):

algorithms/centrality/reaching.py
def _average_weight(G, path, weight=None):
def global_reaching_centrality(G, weight=None, normalized=True):
        def as_distance(u, v, d):
def local_reaching_centrality(G, v, paths=None, weight=None, normalized=True):
            def as_distance(u, v, d):

algorithms/tests/test_swap.py
def test_double_edge_swap():
def test_double_edge_swap_seed():
def test_connected_double_edge_swap():
def test_connected_double_edge_swap_low_window_threshold():
def test_connected_double_edge_swap_star():
def test_connected_double_edge_swap_star_low_window_threshold():
def test_double_edge_swap_small():
def test_double_edge_swap_tries():
def test_double_edge_directed():
def test_double_edge_max_tries():
def test_connected_double_edge_swap_small():
def test_connected_double_edge_swap_not_connected():
def test_degree_seq_c4():

algorithms/centrality/current_flow_closeness.py
def current_flow_closeness_centrality(G, weight=None, dtype=float, solver="lu"):

algorithms/tests/test_sparsifiers.py
def _test_spanner(G, spanner, stretch, weight=None):
def _assign_random_weights(G, seed=None):
def test_spanner_trivial():
def test_spanner_unweighted_complete_graph():
def test_spanner_weighted_complete_graph():
def test_spanner_unweighted_gnp_graph():
def test_spanner_weighted_gnp_graph():
def test_spanner_unweighted_disconnected_graph():
def test_spanner_invalid_stretch():

algorithms/tests/test_smetric.py
def test_smetric():
def test_normalized():

algorithms/tests/test_non_randomness.py
def test_non_randomness(k, weight, expected):
def test_non_connected():
def test_self_loops():

algorithms/tests/test_triads.py
def test_triadic_census():
def test_is_triad():
def test_all_triplets():
def test_all_triads():
def test_triad_type():
def test_triads_by_type():
def test_random_triad():
def test_triadic_census_nodelist():

algorithms/tests/test_core.py
class TestCore:
    def setup_class(cls):
    def test_trivial(self):
    def test_core_number(self):
    def test_core_number2(self):
    def test_directed_core_number(self):
    def test_main_core(self):
    def test_k_core(self):
    def test_main_crust(self):
    def test_k_crust(self):
    def test_main_shell(self):
    def test_k_shell(self):
    def test_k_corona(self):
    def test_k_truss(self):
    def test_onion_layers(self):

algorithms/tests/test_bridges.py
class TestBridges:
    def test_single_bridge(self):
    def test_barbell_graph(self):
    def test_multiedge_bridge(self):
class TestLocalBridges:
    def setup_class(cls):
    def test_nospan(self):
    def test_no_weight(self):
    def test_weight(self):

algorithms/tests/test_chordal.py
class TestMCS:
    def setup_class(cls):
    def test_is_chordal_not_implemented(self, G):
    def test_is_chordal(self):
    def test_induced_nodes(self):
    def test_graph_treewidth(self):
    def test_chordal_find_cliques(self):
    def test_chordal_find_cliques_path(self):
    def test_chordal_find_cliquesCC(self):
    def test_complete_to_chordal_graph(self):

algorithms/tests/test_polynomials.py
def test_tutte_polynomial(G, expected):
def test_tutte_polynomial_disjoint_K1(G):

algorithms/tests/test_boundary.py
class TestNodeBoundary:
    def test_null_graph(self):
    def test_path_graph(self):
    def test_complete_graph(self):
    def test_petersen(self):
        def cheeger(G, k):
    def test_directed(self):
    def test_multigraph(self):
    def test_multidigraph(self):
class TestEdgeBoundary:
    def test_null_graph(self):
    def test_path_graph(self):
    def test_complete_graph(self):
        def ilen(iterable):
    def test_directed(self):
    def test_multigraph(self):
    def test_multidigraph(self):

algorithms/tests/test_regular.py
class TestKFactor:
    def test_k_factor_trivial(self):
    def test_k_factor1(self):
    def test_k_factor2(self):
    def test_k_factor3(self):
    def test_k_factor4(self):
    def test_k_factor5(self):
class TestIsRegular:
    def test_is_regular1(self):
    def test_is_regular2(self):
    def test_is_regular3(self):
    def test_is_regular4(self):
class TestIsKRegular:
    def test_is_k_regular1(self):
    def test_is_k_regular2(self):
    def test_is_k_regular3(self):

algorithms/tests/test_simple_paths.py
class TestIsSimplePath:
    def test_empty_list(self):
    def test_trivial_path(self):
    def test_trivial_nonpath(self):
    def test_simple_path(self):
    def test_non_simple_path(self):
    def test_cycle(self):
    def test_missing_node(self):
    def test_directed_path(self):
    def test_directed_non_path(self):
    def test_directed_cycle(self):
    def test_multigraph(self):
    def test_multidigraph(self):
def test_all_simple_paths():
def test_all_simple_paths_with_two_targets_emits_two_paths():
def test_digraph_all_simple_paths_with_two_targets_emits_two_paths():
def test_all_simple_paths_with_two_targets_cutoff():
def test_digraph_all_simple_paths_with_two_targets_cutoff():
def test_all_simple_paths_with_two_targets_in_line_emits_two_paths():
def test_all_simple_paths_ignores_cycle():
def test_all_simple_paths_with_two_targets_inside_cycle_emits_two_paths():
def test_all_simple_paths_source_target():
def test_all_simple_paths_cutoff():
def test_all_simple_paths_on_non_trivial_graph():
def test_all_simple_paths_multigraph():
def test_all_simple_paths_multigraph_with_cutoff():
def test_all_simple_paths_directed():
def test_all_simple_paths_empty():
def test_all_simple_paths_corner_cases():
def hamiltonian_path(G, source):
def test_hamiltonian_path():
def test_cutoff_zero():
def test_source_missing():
def test_target_missing():
def test_all_simple_edge_paths():
def test_all_simple_edge_paths_with_two_targets_emits_two_paths():
def test_digraph_all_simple_edge_paths_with_two_targets_emits_two_paths():
def test_all_simple_edge_paths_with_two_targets_cutoff():
def test_digraph_all_simple_edge_paths_with_two_targets_cutoff():
def test_all_simple_edge_paths_with_two_targets_in_line_emits_two_paths():
def test_all_simple_edge_paths_ignores_cycle():
def test_all_simple_edge_paths_with_two_targets_inside_cycle_emits_two_paths():
def test_all_simple_edge_paths_source_target():
def test_all_simple_edge_paths_cutoff():
def test_all_simple_edge_paths_on_non_trivial_graph():
def test_all_simple_edge_paths_multigraph():
def test_all_simple_edge_paths_multigraph_with_cutoff():
def test_all_simple_edge_paths_directed():
def test_all_simple_edge_paths_empty():
def test_all_simple_edge_paths_corner_cases():
def hamiltonian_edge_path(G, source):
def test_hamiltonian__edge_path():
def test_edge_cutoff_zero():
def test_edge_source_missing():
def test_edge_target_missing():
def test_shortest_simple_paths():
def test_shortest_simple_paths_directed():
def test_shortest_simple_paths_directed_with_weight_fucntion():
    def cost(u, v, x):
def test_shortest_simple_paths_with_weight_fucntion():
    def cost(u, v, x):
def test_Greg_Bernstein():
def test_weighted_shortest_simple_path():
    def cost_func(path):
def test_directed_weighted_shortest_simple_path():
    def cost_func(path):
def test_weighted_shortest_simple_path_issue2427():
def test_directed_weighted_shortest_simple_path_issue2427():
def test_weight_name():
def test_ssp_source_missing():
def test_ssp_target_missing():
def test_ssp_multigraph():
def test_ssp_source_missing2():
def test_bidirectional_shortest_path_restricted_cycle():
def test_bidirectional_shortest_path_restricted_wheel():
def test_bidirectional_shortest_path_restricted_directed_cycle():
def test_bidirectional_shortest_path_ignore():
def validate_path(G, s, t, soln_len, path):
def validate_length_path(G, s, t, soln_len, length, path):
def test_bidirectional_dijksta_restricted():
def test_bidirectional_dijkstra_no_path():
def test_bidirectional_dijkstra_ignore():

algorithms/tests/test_planar_drawing.py
def test_graph1():
def test_graph2():
def test_circle_graph():
def test_grid_graph():
def test_one_node_graph():
def test_two_node_graph():
def test_three_node_graph():
def test_multiple_component_graph1():
def test_multiple_component_graph2():
def test_invalid_half_edge():
def test_triangulate_embedding1():
def test_triangulate_embedding2():
def check_triangulation(embedding, expected_embedding):
def check_embedding_data(embedding_data):
def is_close(a, b, rel_tol=1e-09, abs_tol=0.0):
def point_in_between(a, b, p):
def check_edge_intersections(G, pos):
class Vector:
    def __init__(self, x, y, node):
    def __eq__(self, other):
    def __lt__(self, other):
    def __ne__(self, other):
    def __le__(self, other):
    def __gt__(self, other):
    def __ge__(self, other):
def planar_drawing_conforms_to_embedding(embedding, pos):

algorithms/tests/test_lowest_common_ancestors.py
def get_pair(dictionary, n1, n2):
class TestTreeLCA:
    def setup_class(cls):
    def assert_has_same_pairs(d1, d2):
    def test_tree_all_pairs_lowest_common_ancestor1(self):
    def test_tree_all_pairs_lowest_common_ancestor2(self):
    def test_tree_all_pairs_lowest_common_ancestor3(self):
    def test_tree_all_pairs_lowest_common_ancestor4(self):
    def test_tree_all_pairs_lowest_common_ancestor5(self):
    def test_tree_all_pairs_lowest_common_ancestor6(self):
    def test_tree_all_pairs_lowest_common_ancestor7(self):
    def test_tree_all_pairs_lowest_common_ancestor8(self):
    def test_tree_all_pairs_lowest_common_ancestor9(self):
    def test_tree_all_pairs_lowest_common_ancestor10(self):
    def test_tree_all_pairs_lowest_common_ancestor12(self):
    def test_not_implemented_for(self):
    def test_tree_all_pairs_lowest_common_ancestor13(self):
class TestDAGLCA:
    def setup_class(cls):
    def assert_lca_dicts_same(self, d1, d2, G=None):
    def test_all_pairs_lowest_common_ancestor1(self):
    def test_all_pairs_lowest_common_ancestor2(self):
    def test_all_pairs_lowest_common_ancestor3(self):
    def test_all_pairs_lowest_common_ancestor4(self):
    def test_all_pairs_lowest_common_ancestor5(self):
    def test_all_pairs_lowest_common_ancestor6(self):
    def test_all_pairs_lowest_common_ancestor7(self):
    def test_all_pairs_lowest_common_ancestor8(self):
    def test_all_pairs_lowest_common_ancestor9(self):
    def test_all_pairs_lowest_common_ancestor10(self):
    def test_lowest_common_ancestor1(self):
    def test_lowest_common_ancestor2(self):

algorithms/tests/test_threshold.py
class TestGeneratorThreshold:
    def test_threshold_sequence_graph_test(self):
    def test_creation_sequences(self):
    def test_make_compact(self):
    def test_uncompact(self):
    def test_creation_sequence_to_weights(self):
    def test_weights_to_creation_sequence(self):
    def test_find_alternating_4_cycle(self):
    def test_shortest_path(self):
    def test_shortest_path_length(self):
    def test_random_threshold_sequence(self):
    def test_right_d_threshold_sequence(self):
    def test_left_d_threshold_sequence(self):
    def test_weights_thresholds(self):
    def test_finding_routines(self):
    def test_fast_versions_properties_threshold_graphs(self):
    def test_tg_creation_routines(self):
    def test_eigenvectors(self):
    def test_create_using(self):

algorithms/tests/test_tournament.py
def test_condition_not_satisfied():
def test_empty_iterable():
def test_is_tournament():
def test_self_loops():
def test_missing_edges():
def test_bidirectional_edges():
def test_graph_is_tournament():
def test_graph_is_tournament_seed():
def test_graph_is_tournament_one_node():
def test_graph_is_tournament_zero_node():
def test_hamiltonian_empty_graph():
def test_path_is_hamiltonian():
def test_hamiltonian_cycle():
def test_score_sequence_edge():
def test_score_sequence_triangle():
def test_tournament_matrix():
def test_reachable_pair():
def test_same_node_is_reachable():
def test_unreachable_pair():
def test_is_strongly_connected():
def test_not_strongly_connected():

algorithms/tests/test_node_classification_deprecations.py
def test_hmn_deprecation_warning():
def test_lgc_deprecation_warning():
def test_no_warn_on_function_import(recwarn):
def test_no_warn_on_package_import(recwarn):

algorithms/tests/test_link_prediction.py
def _test_func(G, ebunch, expected, predict_func, **kwargs):
class TestResourceAllocationIndex:
    def setup_class(cls):
    def test_K5(self):
    def test_P3(self):
    def test_S4(self):
    def test_notimplemented(self):
    def test_no_common_neighbor(self):
    def test_equal_nodes(self):
    def test_all_nonexistent_edges(self):
class TestJaccardCoefficient:
    def setup_class(cls):
    def test_K5(self):
    def test_P4(self):
    def test_notimplemented(self):
    def test_no_common_neighbor(self):
    def test_isolated_nodes(self):
    def test_all_nonexistent_edges(self):
class TestAdamicAdarIndex:
    def setup_class(cls):
    def test_K5(self):
    def test_P3(self):
    def test_S4(self):
    def test_notimplemented(self):
    def test_no_common_neighbor(self):
    def test_equal_nodes(self):
    def test_all_nonexistent_edges(self):
class TestCommonNeighborCentrality:
    def setup_class(cls):
    def test_K5(self):
    def test_P3(self):
    def test_S4(self):
    def test_notimplemented(self, graph_type):
    def test_no_common_neighbor(self):
    def test_equal_nodes(self):
    def test_all_nonexistent_edges(self):
class TestPreferentialAttachment:
    def setup_class(cls):
    def test_K5(self):
    def test_P3(self):
    def test_S4(self):
    def test_notimplemented(self):
    def test_zero_degrees(self):
    def test_all_nonexistent_edges(self):
class TestCNSoundarajanHopcroft:
    def setup_class(cls):
    def test_K5(self):
    def test_P3(self):
    def test_S4(self):
    def test_notimplemented(self):
    def test_no_common_neighbor(self):
    def test_equal_nodes(self):
    def test_different_community(self):
    def test_no_community_information(self):
    def test_insufficient_community_information(self):
    def test_sufficient_community_information(self):
    def test_custom_community_attribute_name(self):
    def test_all_nonexistent_edges(self):
class TestRAIndexSoundarajanHopcroft:
    def setup_class(cls):
    def test_K5(self):
    def test_P3(self):
    def test_S4(self):
    def test_notimplemented(self):
    def test_no_common_neighbor(self):
    def test_equal_nodes(self):
    def test_different_community(self):
    def test_no_community_information(self):
    def test_insufficient_community_information(self):
    def test_sufficient_community_information(self):
    def test_custom_community_attribute_name(self):
    def test_all_nonexistent_edges(self):
class TestWithinInterCluster:
    def setup_class(cls):
    def test_K5(self):
    def test_P3(self):
    def test_S4(self):
    def test_notimplemented(self):
    def test_no_common_neighbor(self):
    def test_equal_nodes(self):
    def test_different_community(self):
    def test_no_inter_cluster_common_neighbor(self):
    def test_no_community_information(self):
    def test_insufficient_community_information(self):
    def test_sufficient_community_information(self):
    def test_invalid_delta(self):
    def test_custom_community_attribute_name(self):
    def test_all_nonexistent_edges(self):

algorithms/tests/test_asteroidal.py
def test_is_at_free():

algorithms/tests/test_node_classification.py
class TestHarmonicFunction:
    def test_path_graph(self):
    def test_no_labels(self):
    def test_no_nodes(self):
    def test_no_edges(self):
    def test_digraph(self):
    def test_one_labeled_node(self):
    def test_nodes_all_labeled(self):
    def test_labeled_nodes_are_not_changed(self):
class TestLocalAndGlobalConsistency:
    def test_path_graph(self):
    def test_no_labels(self):
    def test_no_nodes(self):
    def test_no_edges(self):
    def test_digraph(self):
    def test_one_labeled_node(self):
    def test_nodes_all_labeled(self):

algorithms/tests/test_max_weight_clique.py
class TestMaximumWeightClique:
    def test_basic_cases(self):
        def check_basic_case(graph_func, expected_weight, weight_accessor):
    def test_key_error(self):
    def test_error_on_non_integer_weight(self):
    def test_unaffected_by_self_loops(self):
    def test_30_node_prob(self):
def verify_clique(
def empty_graph():
def one_node_graph():
def two_node_graph():
def three_node_clique():
def three_node_independent_set():
def disconnected():

algorithms/tests/test_dag.py
def _consume(iterator):
class TestDagLongestPath:
    def test_empty(self):
    def test_unweighted1(self):
    def test_unweighted2(self):
    def test_weighted(self):
    def test_undirected_not_implemented(self):
    def test_unorderable_nodes(self):
class TestDagLongestPathLength:
    def test_unweighted(self):
    def test_undirected_not_implemented(self):
    def test_weighted(self):
class TestDAG:
    def setup_class(cls):
    def test_topological_sort1(self):
    def test_is_directed_acyclic_graph(self):
    def test_topological_sort2(self):
    def test_topological_sort3(self):
        def validate(order):
    def test_topological_sort4(self):
    def test_topological_sort5(self):
    def test_topological_sort6(self):
            def runtime_error():
            def unfeasible_error():
            def runtime_error2():
    def test_all_topological_sorts_1(self):
    def test_all_topological_sorts_2(self):
    def test_all_topological_sorts_3(self):
        def unfeasible():
        def not_implemented():
        def not_implemted_2():
    def test_all_topological_sorts_4(self):
    def test_all_topological_sorts_multigraph_1(self):
    def test_all_topological_sorts_multigraph_2(self):
    def test_ancestors(self):
    def test_descendants(self):
    def test_transitive_closure(self):
    def test_reflexive_transitive_closure(self):
    def test_transitive_closure_dag(self):
    def test_transitive_reduction(self):
    def _check_antichains(self, solution, result):
    def test_antichains(self):
        def f(x):
    def test_lexicographical_topological_sort(self):
    def test_lexicographical_topological_sort2(self):
        class Test_Node:
            def __init__(self, n):
            def __repr__(self):
        def sorting_key(node):
def test_topological_generations():
def test_topological_generations_empty():
def test_topological_generations_cycle():
def test_is_aperiodic_cycle():
def test_is_aperiodic_cycle2():
def test_is_aperiodic_cycle3():
def test_is_aperiodic_cycle4():
def test_is_aperiodic_selfloop():
def test_is_aperiodic_raise():
def test_is_aperiodic_bipartite():
def test_is_aperiodic_rary_tree():
def test_is_aperiodic_disconnected():
def test_is_aperiodic_disconnected2():
class TestDagToBranching:
    def test_single_root(self):
    def test_multiple_roots(self):
    def test_already_arborescence(self):
    def test_already_branching(self):
    def test_not_acyclic(self):
    def test_undirected(self):
    def test_multigraph(self):
    def test_multidigraph(self):
def test_ancestors_descendants_undirected():

algorithms/dominating.py
def dominating_set(G, start_with=None):
def is_dominating_set(G, nbunch):

algorithms/tests/test_cycles.py
class TestCycles:
    def setup_class(cls):
    def is_cyclic_permutation(self, a, b):
    def test_cycle_basis(self):
    def test_cycle_basis2(self):
    def test_cycle_basis3(self):
    def test_simple_cycles(self):
    def test_simple_cycles_graph(self):
    def test_unsortable(self):
    def test_simple_cycles_small(self):
    def test_simple_cycles_empty(self):
    def test_complete_directed_graph(self):
    def worst_case_graph(self, k):
    def test_worst_case_graph(self):
    def test_recursive_simple_and_not(self):
    def test_simple_graph_with_reported_bug(self):
class TestFindCycle:
    def setup_class(cls):
    def test_graph_nocycle(self):
    def test_graph_cycle(self):
    def test_graph_orientation_none(self):
    def test_graph_orientation_original(self):
    def test_digraph(self):
    def test_digraph_orientation_none(self):
    def test_digraph_orientation_original(self):
    def test_multigraph(self):
    def test_multidigraph(self):
    def test_digraph_ignore(self):
    def test_digraph_reverse(self):
    def test_multidigraph_ignore(self):
    def test_multidigraph_ignore2(self):
    def test_multidigraph_original(self):
    def test_dag(self):
    def test_prev_explored(self):
    def test_no_cycle(self):
def assert_basis_equal(a, b):
class TestMinimumCycles:
    def setup_class(cls):
    def test_unweighted_diamond(self):
    def test_weighted_diamond(self):
    def test_dimensionality(self):
    def test_complete_graph(self):
    def test_tree_graph(self):

algorithms/lowest_common_ancestors.py
def tree_all_pairs_lowest_common_ancestor(G, root=None, pairs=None):
def lowest_common_ancestor(G, node1, node2, default=None):
def all_pairs_lowest_common_ancestor(G, pairs=None):
    def _compute_dag_lca_from_tree_values(tree_lca, dry_run):
            def get_next_in_merged_lists(indices):

algorithms/moral.py
def moral_graph(G):

algorithms/structuralholes.py
def mutual_weight(G, u, v, weight=None):
def normalized_mutual_weight(G, u, v, norm=sum, weight=None):
def effective_size(G, nodes=None, weight=None):
    def redundancy(G, u, v, weight=None):
def constraint(G, nodes=None, weight=None):
def local_constraint(G, u, v, weight=None):

algorithms/clique.py
def enumerate_all_cliques(G):
def find_cliques(G, nodes=None):
def find_cliques_recursive(G, nodes=None):
    def expand(subg, cand):
def make_max_clique_graph(G, create_using=None):
def make_clique_bipartite(G, fpos=None, create_using=None, name=None):
def graph_clique_number(G, cliques=None):
def graph_number_of_cliques(G, cliques=None):
def node_clique_number(G, nodes=None, cliques=None, separate_nodes=False):
def number_of_cliques(G, nodes=None, cliques=None):
def cliques_containing_node(G, nodes=None, cliques=None):
class MaxWeightClique:
    def __init__(self, G, weight):
    def update_incumbent_if_improved(self, C, C_weight):
    def greedily_find_independent_set(self, P):
    def find_branching_nodes(self, P, target):
    def expand(self, C, C_weight, P):
    def find_max_weight_clique(self):
def max_weight_clique(G, weight="weight"):

algorithms/sparsifiers.py
def spanner(G, stretch, weight=None, seed=None):
def _setup_residual_graph(G, weight):
def _lightest_edge_dicts(residual_graph, clustering, node):
def _add_edge_to_spanner(H, residual_graph, u, v, weight):

algorithms/operators/unary.py
def complement(G):
def reverse(G, copy=True):

algorithms/approximation/ramsey.py
def ramsey_R2(G):

algorithms/similarity.py
def debug_print(*args, **kwargs):
def graph_edit_distance(
def optimal_edit_paths(
def optimize_graph_edit_distance(
def optimize_edit_paths(
    class CostMatrix:
        def __init__(self, C, lsa_row_ind, lsa_col_ind, ls):
    def make_CostMatrix(C, m, n):
    def extract_C(C, i, j, m, n):
    def reduce_C(C, i, j, m, n):
    def reduce_ind(ind, i):
    def match_edges(u, v, pending_g, pending_h, Ce, matched_uv=[]):
    def reduce_Ce(Ce, ij, m, n):
    def get_edit_ops(
    def get_edit_paths(
    class MaxCost:
        def __init__(self):
    def prune(cost):
def simrank_similarity(
        def simrank(G, u, v):
def _simrank_similarity_python(
    def avg_sim(s):
    def sim(u, v):
def _simrank_similarity_numpy(
def simrank_similarity_numpy(
def panther_similarity(G, source, k=5, path_length=5, c=0.5, delta=0.1, eps=None):
def generate_random_paths(G, sample_size, path_length=5, index_map=None):

algorithms/approximation/distance_measures.py
def diameter(G, seed=None):
def _two_sweep_undirected(G, seed):
def _two_sweep_directed(G, seed):

algorithms/approximation/treewidth.py
def treewidth_min_degree(G):
def treewidth_min_fill_in(G):
class MinDegreeHeuristic:
    def __init__(self, graph):
    def best_node(self, graph):
def min_fill_in_heuristic(graph):
def treewidth_decomp(G, heuristic=min_fill_in_heuristic):

algorithms/approximation/kcomponents.py
def k_components(G, min_density=0.95):
def _cliques_heuristic(G, H, k, min_density):
def _same(measure, tol=0):
class _AntiGraph(nx.Graph):
    def single_edge_dict(self):
    def __getitem__(self, n):
    def neighbors(self, n):
    class AntiAtlasView(Mapping):
        def __init__(self, graph, node):
        def __len__(self):
        def __iter__(self):
        def __getitem__(self, nbr):
    class AntiAdjacencyView(AntiAtlasView):
        def __init__(self, graph):
        def __len__(self):
        def __iter__(self):
        def __getitem__(self, node):
    def adj(self):
    def subgraph(self, nodes):
    class AntiDegreeView(nx.reportviews.DegreeView):
        def __iter__(self):
        def __getitem__(self, n):
    def degree(self):
    def adjacency(self):

algorithms/operators/product.py
def _dict_product(d1, d2):
def _node_product(G, H):
def _directed_edges_cross_edges(G, H):
def _undirected_edges_cross_edges(G, H):
def _edges_cross_nodes(G, H):
def _nodes_cross_edges(G, H):
def _edges_cross_nodes_and_nodes(G, H):
def _init_product_graph(G, H):
def tensor_product(G, H):
def cartesian_product(G, H):
def lexicographic_product(G, H):
def strong_product(G, H):
def power(G, k):
def rooted_product(G, H, root):

algorithms/operators/tests/test_unary.py
def test_complement():
def test_complement_2():
def test_reverse1():

algorithms/approximation/vertex_cover.py
def min_weighted_vertex_cover(G, weight=None):

algorithms/operators/tests/test_binary.py
def test_union_attributes():
def test_intersection():
def test_intersection_node_sets_different():
def test_intersection_attributes():
def test_intersection_attributes_node_sets_different():
def test_intersection_multigraph_attributes():
def test_intersection_multigraph_attributes_node_set_different():
def test_difference():
def test_difference2():
def test_difference_attributes():
def test_difference_multigraph_attributes():
def test_difference_raise():
def test_symmetric_difference_multigraph():
def test_union_and_compose():
def test_union_multigraph():
def test_disjoint_union_multigraph():
def test_compose_multigraph():
def test_full_join_graph():
def test_full_join_multigraph():
def test_mixed_type_union():

algorithms/operators/tests/test_all.py
def test_union_all_attributes():
def test_intersection_all():
def test_intersection_all_different_node_sets():
def test_intersection_all_attributes():
def test_intersection_all_attributes_different_node_sets():
def test_intersection_all_multigraph_attributes():
def test_intersection_all_multigraph_attributes_different_node_sets():
def test_union_all_and_compose_all():
def test_union_all_multigraph():
def test_input_output():
def test_mixed_type_union():
def test_mixed_type_disjoint_union():
def test_mixed_type_intersection():
def test_mixed_type_compose():
def test_empty_union():
def test_empty_disjoint_union():
def test_empty_compose_all():
def test_empty_intersection_all():

algorithms/operators/tests/test_product.py
def test_tensor_product_raises():
def test_tensor_product_null():
def test_tensor_product_size():
def test_tensor_product_combinations():
def test_tensor_product_classic_result():
def test_tensor_product_random():
def test_cartesian_product_multigraph():
def test_cartesian_product_raises():
def test_cartesian_product_null():
def test_cartesian_product_size():
def test_cartesian_product_classic():
def test_cartesian_product_random():
def test_lexicographic_product_raises():
def test_lexicographic_product_null():
def test_lexicographic_product_size():
def test_lexicographic_product_combinations():
def test_lexicographic_product_random():
def test_strong_product_raises():
def test_strong_product_null():
def test_strong_product_size():
def test_strong_product_combinations():
def test_strong_product_random():
def test_graph_power_raises():
def test_graph_power():
def test_graph_power_negative():
def test_rooted_product_raises():
def test_rooted_product():

algorithms/approximation/matching.py
def min_maximal_matching(G):

algorithms/operators/all.py
def union_all(graphs, rename=(None,)):
    def add_prefix(graph, prefix):
        def label(x):
def disjoint_union_all(graphs):
def compose_all(graphs):
def intersection_all(graphs):

algorithms/operators/binary.py
def union(G, H, rename=(None, None), name=None):
def disjoint_union(G, H):
def intersection(G, H):
def difference(G, H):
def symmetric_difference(G, H):
def compose(G, H):
def full_join(G, H, rename=(None, None)):
    def add_prefix(graph, prefix):
        def label(x):

algorithms/approximation/dominating_set.py
def min_weighted_dominating_set(G, weight=None):
    def _cost(node_and_neighborhood):
def min_edge_dominating_set(G):

algorithms/connectivity/cuts.py
def minimum_st_edge_cut(G, s, t, flow_func=None, auxiliary=None, residual=None):
def minimum_st_node_cut(G, s, t, flow_func=None, auxiliary=None, residual=None):
def minimum_node_cut(G, s=None, t=None, flow_func=None):
        def neighbors(v):
def minimum_edge_cut(G, s=None, t=None, flow_func=None):

algorithms/approximation/maxcut.py
def randomized_partitioning(G, seed=None, p=0.5, weight=None):
def _swap_node_partition(cut, node):
def one_exchange(G, initial_cut=None, seed=None, weight=None):

algorithms/connectivity/utils.py
def build_auxiliary_node_connectivity(G):
def build_auxiliary_edge_connectivity(G):

algorithms/connectivity/kcutsets.py
def all_node_cuts(G, k=None, flow_func=None):
def _is_separating_set(G, cut):

algorithms/connectivity/stoerwagner.py
def stoer_wagner(G, weight="weight", heap=BinaryHeap):

algorithms/approximation/tests/test_approx_clust_coeff.py
def test_petersen():
def test_petersen_seed():
def test_tetrahedral():
def test_dodecahedral():
def test_empty():
def test_complete():

algorithms/approximation/tests/test_clique.py
def is_independent_set(G, nodes):
def is_clique(G, nodes):
class TestCliqueRemoval:
    def test_trivial_graph(self):
    def test_complete_graph(self):
    def test_barbell_graph(self):
class TestMaxClique:
    def test_null_graph(self):
    def test_complete_graph(self):
    def test_maximal_by_cardinality(self):
def test_large_clique_size():
def test_independent_set():

algorithms/approximation/tests/test_matching.py
def test_min_maximal_matching():

algorithms/approximation/tests/test_dominating_set.py
class TestMinWeightDominatingSet:
    def test_min_weighted_dominating_set(self):
    def test_star_graph(self):
    def test_min_edge_dominating_set(self):

algorithms/approximation/tests/test_connectivity.py
def test_global_node_connectivity():
def test_white_harary1():
def test_complete_graphs():
def test_empty_graphs():
def test_petersen():
def test_dodecahedral():
def test_octahedral():
def test_only_source():
def test_only_target():
def test_missing_source():
def test_missing_target():
def test_source_equals_target():
def test_directed_node_connectivity():
class TestAllPairsNodeConnectivityApprox:
    def setup_class(cls):
    def test_cycles(self):
    def test_complete(self):
    def test_paths(self):
    def test_cutoff(self):
    def test_all_pairs_connectivity_nbunch(self):

algorithms/approximation/tests/test_kcomponents.py
def build_k_number_dict(k_components):
def graph_example_1():
def torrents_and_ferraro_graph():
def _check_connectivity(G):
def test_torrents_and_ferraro_graph():
def test_example_1():
def test_karate_0():
def test_karate_1():
def test_example_1_detail_3_and_4():
def test_directed():
def test_same():
class TestAntiGraph:
    def setup_class(cls):
    def test_size(self):
    def test_degree(self):
    def test_core_number(self):
    def test_connected_components(self):
    def test_adj(self):
    def test_adjacency(self):
    def test_neighbors(self):
    def test_node_not_in_graph(self):
    def test_degree_thingraph(self):

algorithms/approximation/tests/test_maxcut.py
def _is_valid_cut(G, set1, set2):
def _cut_is_locally_optimal(G, cut_size, set1):
def test_random_partitioning():
def test_random_partitioning_all_to_one():
def test_one_exchange_basic():
def test_one_exchange_optimal():
def test_negative_weights():

algorithms/approximation/tests/test_distance_measures.py
class TestDiameter:
    def test_null_graph(self):
    def test_undirected_non_connected(self):
    def test_directed_non_strongly_connected(self):
    def test_complete_undirected_graph(self):
    def test_complete_directed_graph(self):
    def test_undirected_path_graph(self):
    def test_directed_path_graph(self):
    def test_single_node(self):

algorithms/approximation/traveling_salesman.py
def swap_two_nodes(soln, seed):
def move_one_node(soln, seed):
def christofides(G, weight="weight", tree=None):
def _shortcutting(circuit):
def traveling_salesman_problem(G, weight="weight", nodes=None, cycle=True, method=None):
def asadpour_atsp(G, weight="weight", seed=None, source=None):
def held_karp_ascent(G, weight="weight"):
    def k_pi():
    def direction_of_ascent():
    def find_epsilon(k, d):
def total_spanning_tree_weight(G, weight=None):
def spanning_tree_distribution(G, z):
    def q(e):
def sample_spanning_tree(G, lambda_key, seed=None):
    def find_node(merged_nodes, n):
    def prepare_graph():
def greedy_tsp(G, weight="weight", source=None):
def simulated_annealing_tsp(
def threshold_accepting_tsp(

algorithms/approximation/tests/test_steinertree.py
class TestSteinerTree:
    def setup_class(cls):
    def test_connected_metric_closure(self):
    def test_metric_closure(self):
    def test_steiner_tree(self):
    def test_multigraph_steiner_tree(self):

algorithms/approximation/tests/test_vertex_cover.py
def is_cover(G, node_cover):
class TestMWVC:
    def test_unweighted_directed(self):
    def test_unweighted_undirected(self):
    def test_weighted(self):
    def test_unweighted_self_loop(self):

algorithms/approximation/tests/test_ramsey.py
def test_ramsey():

algorithms/approximation/steinertree.py
def metric_closure(G, weight="weight"):
def steiner_tree(G, terminal_nodes, weight="weight"):

algorithms/approximation/tests/test_traveling_salesman.py
def test_christofides_hamiltonian():
def test_christofides_incomplete_graph():
def test_christofides_ignore_selfloops():
class TestBase:
    def setup_class(cls):
def validate_solution(soln, cost, exp_soln, exp_cost):
def validate_symmetric_solution(soln, cost, exp_soln, exp_cost):
class TestGreedyTSP(TestBase):
    def test_greedy(self):
    def test_not_complete_graph(self):
    def test_not_weighted_graph(self):
    def test_two_nodes(self):
    def test_ignore_selfloops(self):
class TestSimulatedAnnealingTSP(TestBase):
    def test_simulated_annealing_directed(self):
    def test_simulated_annealing_undirected(self):
    def test_error_on_input_order_mistake(self):
    def test_not_complete_graph(self):
    def test_ignore_selfloops(self):
    def test_not_weighted_graph(self):
    def test_two_nodes(self):
    def test_failure_of_costs_too_high_when_iterations_low(self):
class TestThresholdAcceptingTSP(TestSimulatedAnnealingTSP):
    def test_failure_of_costs_too_high_when_iterations_low(self):
def test_TSP_method():
    def my_tsp_method(G, weight):
def test_TSP_unweighted():
def test_TSP_weighted():
def test_TSP_incomplete_graph_short_path():
def test_held_karp_ascent():
def test_ascent_fractional_solution():
def test_ascent_method_asymmetric():
def test_ascent_method_asymmetric_2():
def test_held_karp_ascent_asymmetric_3():
def test_held_karp_ascent_fractional_asymmetric():
def test_spanning_tree_distribution():
def test_sample_spanning_tree():
def test_sample_spanning_tree_large_sample():
def test_asadpour_tsp():
    def fixed_asadpour(G, weight):
def test_asadpour_real_world():
    def fixed_asadpour(G, weight):
def test_asadpour_real_world_path():
    def fixed_asadpour(G, weight):
def test_asadpour_disconnected_graph():
def test_asadpour_incomplete_graph():
def test_asadpour_empty_graph():
def test_asadpour_integral_held_karp():
def test_directed_tsp_impossible():

algorithms/approximation/tests/test_treewidth.py
def is_tree_decomp(graph, decomp):
class TestTreewidthMinDegree:
    def setup_class(cls):
    def test_petersen_graph(self):
    def test_small_tree_treewidth(self):
    def test_heuristic_abort(self):
    def test_empty_graph(self):
    def test_two_component_graph(self):
    def test_heuristic_first_steps(self):
class TestTreewidthMinFillIn:
    def setup_class(cls):
    def test_petersen_graph(self):
    def test_small_tree_treewidth(self):
    def test_heuristic_abort(self):
    def test_empty_graph(self):
    def test_two_component_graph(self):
    def test_heuristic_first_steps(self):

algorithms/approximation/clique.py
def maximum_independent_set(G):
def max_clique(G):
def clique_removal(G):
def large_clique_size(G):
    def _clique_heuristic(G, U, size, best_size):

algorithms/approximation/clustering_coefficient.py
def average_clustering(G, trials=1000, seed=None):

algorithms/approximation/connectivity.py
def local_node_connectivity(G, source, target, cutoff=None):
def node_connectivity(G, s=None, t=None):
        def neighbors(v):
def all_pairs_node_connectivity(G, nbunch=None, cutoff=None):
def _bidirectional_shortest_path(G, source, target, exclude):
def _bidirectional_pred_succ(G, source, target, exclude):

algorithms/connectivity/kcomponents.py
def k_components(G, flow_func=None):
def _consolidate(sets, k):
def _generate_partition(G, cuts, k):
    def has_nbrs_in_partition(G, node, partition):
def _reconstruct_k_components(k_comps):
def build_k_number_dict(kcomps):

algorithms/connectivity/tests/test_cuts.py
def _generate_no_biconnected(max_attempts=50):
def test_articulation_points():
def test_brandes_erlebach_book():
def test_white_harary_paper():
def test_petersen_cutset():
def test_octahedral_cutset():
def test_icosahedral_cutset():
def test_node_cutset_exception():
def test_node_cutset_random_graphs():
def test_edge_cutset_random_graphs():
def test_empty_graphs():
def test_unbounded():
def test_missing_source():
def test_missing_target():
def test_not_weakly_connected():
def test_not_connected():
def tests_min_cut_complete():
def tests_min_cut_complete_directed():
def tests_minimum_st_node_cut():
def test_invalid_auxiliary():
def test_interface_only_source():
def test_interface_only_target():

algorithms/connectivity/tests/test_disjoint_paths.py
def is_path(G, path):
def are_edge_disjoint_paths(G, paths):
def are_node_disjoint_paths(G, paths):
def test_graph_from_pr_2053():
def test_florentine_families():
def test_karate():
def test_petersen_disjoint_paths():
def test_octahedral_disjoint_paths():
def test_icosahedral_disjoint_paths():
def test_cutoff_disjoint_paths():
def test_missing_source_edge_paths():
def test_missing_source_node_paths():
def test_missing_target_edge_paths():
def test_missing_target_node_paths():
def test_not_weakly_connected_edges():
def test_not_weakly_connected_nodes():
def test_not_connected_edges():
def test_not_connected_nodes():
def test_isolated_edges():
def test_isolated_nodes():
def test_invalid_auxiliary():

algorithms/connectivity/tests/test_edge_augmentation.py
def tarjan_bridge_graph():
def test_weight_key():
def test_is_locally_k_edge_connected_exceptions():
def test_is_k_edge_connected():
def test_is_k_edge_connected_exceptions():
def test_is_locally_k_edge_connected():
def test_null_graph():
def test_cliques():
def test_clique_and_node():
def test_point_graph():
def test_edgeless_graph():
def test_invalid_k():
def test_unfeasible():
def test_tarjan():
def test_configuration():
def test_shell():
def test_karate():
def test_star():
def test_barbell():
def test_bridge():
def test_gnp_augmentation():
def _assert_solution_properties(G, aug_edges, avail_dict=None):
def _augment_and_check(
def _check_augmentations(G, avail=None, max_k=None, weight=None, verbose=False):
def _check_unconstrained_bridge_property(G, info1):

algorithms/connectivity/tests/test_connectivity.py
def _generate_no_biconnected(max_attempts=50):
def test_average_connectivity():
def test_average_connectivity_directed():
def test_articulation_points():
def test_brandes_erlebach():
def test_white_harary_1():
def test_white_harary_2():
def test_complete_graphs():
def test_empty_graphs():
def test_petersen():
def test_tutte():
def test_dodecahedral():
def test_octahedral():
def test_icosahedral():
def test_missing_source():
def test_missing_target():
def test_edge_missing_source():
def test_edge_missing_target():
def test_not_weakly_connected():
def test_not_connected():
def test_directed_edge_connectivity():
def test_cutoff():
def test_invalid_auxiliary():
def test_interface_only_source():
def test_interface_only_target():
def test_edge_connectivity_flow_vs_stoer_wagner():
class TestAllPairsNodeConnectivity:
    def setup_class(cls):
    def test_cycles(self):
    def test_complete(self):
    def test_paths(self):
    def test_all_pairs_connectivity_nbunch(self):
    def test_all_pairs_connectivity_icosahedral(self):
    def test_all_pairs_connectivity(self):
    def test_all_pairs_connectivity_directed(self):
    def test_all_pairs_connectivity_nbunch_combinations(self):
    def test_all_pairs_connectivity_nbunch_iter(self):

algorithms/connectivity/tests/test_stoer_wagner.py
def _check_partition(G, cut_value, partition, weight):
def _test_stoer_wagner(G, answer, weight="weight"):
def test_graph1():
def test_graph2():
def test_graph3():
def test_weight_name():
def test_exceptions():

algorithms/connectivity/tests/test_edge_kcomponents.py
def fset(list_of_sets):
def _assert_subgraph_edge_connectivity(G, ccs_subgraph, k):
def _memo_connectivity(G, u, v, memo):
def _all_pairs_connectivity(G, cc, k, memo):
def _assert_local_cc_edge_connectivity(G, ccs_local, k, memo):
def _check_edge_connectivity(G):
def test_zero_k_exception():
def test_empty_input():
def test_not_implemented():
def test_general_k_edge_subgraph_quick_return():
def test_random_gnp():
def test_configuration():
def test_shell():
def test_karate():
def test_tarjan_bridge():
def test_bridge_cc():
def test_undirected_aux_graph():
def test_local_subgraph_difference():
def test_local_subgraph_difference_directed():
def test_triangles():
def test_four_clique():
def test_five_clique():
def test_directed_aux_graph():
def test_random_gnp_directed():
def test_configuration_directed():
def test_shell_directed():
def test_karate_directed():

algorithms/connectivity/tests/test_kcutsets.py
def graph_example_1():
def torrents_and_ferraro_graph():
def _check_separating_sets(G):
def test_torrents_and_ferraro_graph():
def test_example_1():
def test_random_gnp():
def test_shell():
def test_configuration():
def test_karate():
def _generate_no_biconnected(max_attempts=50):
def test_articulation_points():
def test_grid_2d_graph():
def test_disconnected_graph():
def test_alternative_flow_functions():
def test_is_separating_set_complete_graph():
def test_is_separating_set():
def test_non_repeated_cuts():
def test_cycle_graph():
def test_complete_graph():

algorithms/connectivity/tests/test_kcomponents.py
def torrents_and_ferraro_graph():
def test_directed():
def _check_connectivity(G, k_components):
def test_torrents_and_ferraro_graph():
def test_random_gnp():
def test_shell():
def test_configuration():
def test_karate():
def test_karate_component_number():
def test_davis_southern_women():
def test_davis_southern_women_detail_3_and_4():
def test_set_consolidation_rosettacode():
    def list_of_sets_equal(result, solution):

algorithms/connectivity/disjoint_paths.py
def edge_disjoint_paths(
def node_disjoint_paths(
def _unique_everseen(iterable):

algorithms/connectivity/edge_kcomponents.py
def k_edge_components(G, k):
def k_edge_subgraphs(G, k):
def _k_edge_subgraphs_nodes(G, k):
def bridge_components(G):
class EdgeComponentAuxGraph:
    def construct(EdgeComponentAuxGraph, G):
        def _recursive_build(H, A, source, avail):
    def k_edge_components(self, k):
    def k_edge_subgraphs(self, k):
def _low_degree_nodes(G, k, nbunch=None):
def _high_degree_components(G, k):
def general_k_edge_subgraphs(G, k):

algorithms/connectivity/edge_augmentation.py
def is_k_edge_connected(G, k):
def is_locally_k_edge_connected(G, s, t, k):
def k_edge_augmentation(G, k, avail=None, weight=None, partial=False):
def partial_k_edge_augmentation(G, k, avail, weight=None):
    def _edges_between_disjoint(H, only1, only2):
def one_edge_augmentation(G, avail=None, weight=None, partial=False):
def bridge_augmentation(G, avail=None, weight=None):
def _ordered(u, v):
def _unpack_available_edges(avail, weight=None, G=None):
        def _try_getitem(d):
def _lightest_meta_edges(mapping, avail_uv, avail_w):
def unconstrained_one_edge_augmentation(G):
def weighted_one_edge_augmentation(G, avail, weight=None, partial=False):
def unconstrained_bridge_augmentation(G):
def weighted_bridge_augmentation(G, avail, weight=None):
def _minimum_rooted_branching(D, root):
def collapse(G, grouped_nodes):
def complement_edges(G):
def _compat_shuffle(rng, input):
def greedy_k_edge_augmentation(G, k, avail=None, weight=None, seed=None):

algorithms/smallworld.py
def random_reference(G, niter=1, connectivity=True, seed=None):
def lattice_reference(G, niter=5, D=None, connectivity=True, seed=None):
def sigma(G, niter=100, nrand=10, seed=None):
def omega(G, niter=5, nrand=10, seed=None):

algorithms/connectivity/connectivity.py
def local_node_connectivity(
def node_connectivity(G, s=None, t=None, flow_func=None):
        def neighbors(v):
def average_node_connectivity(G, flow_func=None):
def all_pairs_node_connectivity(G, nbunch=None, flow_func=None):
def local_edge_connectivity(
def edge_connectivity(G, s=None, t=None, flow_func=None, cutoff=None):

algorithms/regular.py
def is_regular(G):
def is_k_regular(G, k):
def k_factor(G, k, matching_weight="weight"):
    class LargeKGadget:
        def __init__(self, k, degree, node, g):
        def replace_node(self):
        def restore_node(self):
    class SmallKGadget:
        def __init__(self, k, degree, node, g):
        def replace_node(self):
        def restore_node(self):

algorithms/bridges.py
def bridges(G, root=None):
def has_bridges(G, root=None):
def local_bridges(G, with_span=True, weight=None):
                def hide_edge(n, nbr, d):

algorithms/chains.py
def chain_decomposition(G, root=None):
    def _dfs_cycle_forest(G, root=None):
    def _build_chain(G, u, v, visited):

algorithms/richclub.py
def rich_club_coefficient(G, normalized=True, Q=100, seed=None):
def _compute_rc(G):

algorithms/wiener.py
def wiener_index(G, weight=None):

tests/test_exceptions.py
def test_raises_networkxexception():
def test_raises_networkxerr():
def test_raises_networkx_pointless_concept():
def test_raises_networkxalgorithmerr():
def test_raises_networkx_unfeasible():
def test_raises_networkx_no_path():
def test_raises_networkx_unbounded():

algorithms/boundary.py
def edge_boundary(G, nbunch1, nbunch2=None, data=False, keys=False, default=None):
def node_boundary(G, nbunch1, nbunch2=None):

algorithms/tree/operations.py
def join(rooted_trees, label_attribute=None):

algorithms/tree/decomposition.py
def junction_tree(G):

algorithms/tree/tests/test_decomposition.py
def test_junction_tree_directed_confounders():
def test_junction_tree_directed_unconnected_nodes():
def test_junction_tree_directed_cascade():
def test_junction_tree_directed_unconnected_edges():
def test_junction_tree_undirected():

algorithms/tree/tests/test_mst.py
def test_unknown_algorithm():
class MinimumSpanningTreeTestBase:
    def setup_method(self, method):
    def test_minimum_edges(self):
    def test_maximum_edges(self):
    def test_without_data(self):
    def test_nan_weights(self):
    def test_nan_weights_order(self):
    def test_isolated_node(self):
    def test_minimum_tree(self):
    def test_maximum_tree(self):
    def test_disconnected(self):
    def test_empty_graph(self):
    def test_attributes(self):
    def test_weight_attribute(self):
class TestBoruvka(MinimumSpanningTreeTestBase):
    def test_unicode_name(self):
class MultigraphMSTTestBase(MinimumSpanningTreeTestBase):
    def test_multigraph_keys_min(self):
    def test_multigraph_keys_max(self):
class TestKruskal(MultigraphMSTTestBase):
class TestPrim(MultigraphMSTTestBase):
    def test_multigraph_keys_tree(self):
    def test_multigraph_keys_tree_max(self):
class TestSpanningTreeIterator:
    def setup(self):
    def test_minimum_spanning_tree_iterator(self):
    def test_maximum_spanning_tree_iterator(self):

algorithms/isomorphism/isomorph.py
def could_be_isomorphic(G1, G2):
def fast_could_be_isomorphic(G1, G2):
def faster_could_be_isomorphic(G1, G2):
def is_isomorphic(G1, G2, node_match=None, edge_match=None):

algorithms/isomorphism/temporalisomorphvf2.py
class TimeRespectingGraphMatcher(GraphMatcher):
    def __init__(self, G1, G2, temporal_attribute_name, delta):
    def one_hop(self, Gx, Gx_node, neighbors):
    def two_hop(self, Gx, core_x, Gx_node, neighbors):
    def semantic_feasibility(self, G1_node, G2_node):
class TimeRespectingDiGraphMatcher(DiGraphMatcher):
    def __init__(self, G1, G2, temporal_attribute_name, delta):
    def get_pred_dates(self, Gx, Gx_node, core_x, pred):
    def get_succ_dates(self, Gx, Gx_node, core_x, succ):
    def one_hop(self, Gx, Gx_node, core_x, pred, succ):
    def two_hop_pred(self, Gx, Gx_node, core_x, pred):
    def two_hop_succ(self, Gx, Gx_node, core_x, succ):
    def preds(self, Gx, core_x, v, Gx_node=None):
    def succs(self, Gx, core_x, v, Gx_node=None):
    def test_one(self, pred_dates, succ_dates):
    def test_two(self, pred_dates, succ_dates):
    def semantic_feasibility(self, G1_node, G2_node):

algorithms/tree/tests/test_operations.py
class TestJoin:
    def test_empty_sequence(self):
    def test_single(self):
    def test_basic(self):

algorithms/tree/tests/test_branchings.py
def G1():
def G2():
def build_branching(edges):
def sorted_edges(G, attr="weight", default=1):
def assert_equal_branchings(G1, G2, attr="weight", default=1):
def test_optimal_branching1():
def test_optimal_branching2a():
def test_optimal_branching2b():
def test_optimal_arborescence2():
def test_greedy_suboptimal_branching1a():
def test_greedy_suboptimal_branching1b():
def test_greedy_max1():
def test_greedy_max2():
def test_greedy_max3():
def test_greedy_min():
def test_edmonds1_maxbranch():
def test_edmonds1_maxarbor():
def test_edmonds2_maxbranch():
def test_edmonds2_maxarbor():
def test_edmonds2_minarbor():
def test_edmonds3_minbranch1():
def test_edmonds3_minbranch2():
def test_mst():
def test_mixed_nodetypes():
def test_edmonds1_minbranch():
def test_edge_attribute_preservation_normal_graph():
def test_edge_attribute_preservation_multigraph():
def test_edge_attribute_discard():
def test_partition_spanning_arborescence():
def test_arborescence_iterator_min():
def test_arborescence_iterator_max():
def test_arborescence_iterator_initial_partition():

algorithms/tree/tests/test_coding.py
class TestPruferSequence:
    def test_nontree(self):
    def test_null_graph(self):
    def test_trivial_graph(self):
    def test_bad_integer_labels(self):
    def test_encoding(self):
    def test_decoding(self):
    def test_decoding2(self):
    def test_inverse(self):
class TestNestedTuple:
    def test_nontree(self):
    def test_unknown_root(self):
    def test_encoding(self):
    def test_canonical_form(self):
    def test_decoding(self):
    def test_sensible_relabeling(self):

algorithms/tree/mst.py
class EdgePartition(Enum):
def boruvka_mst_edges(
    def best_edge(component):
def kruskal_mst_edges(
def prim_mst_edges(G, minimum, weight="weight", keys=True, data=True, ignore_nan=False):
def minimum_spanning_edges(
def maximum_spanning_edges(
def minimum_spanning_tree(G, weight="weight", algorithm="kruskal", ignore_nan=False):
def partition_spanning_tree(
def maximum_spanning_tree(G, weight="weight", algorithm="kruskal", ignore_nan=False):
class SpanningTreeIterator:
    class Partition:
        def __copy__(self):
    def __init__(self, G, weight="weight", minimum=True, ignore_nan=False):
    def __iter__(self):
    def __next__(self):
    def _partition(self, partition, partition_tree):
    def _write_partition(self, partition):
    def _clear_partition(self, G):

algorithms/tree/tests/test_recognition.py
class TestTreeRecognition:
    def setup_class(cls):
    def test_null_tree(self):
    def test_null_tree2(self):
    def test_null_forest(self):
    def test_null_forest2(self):
    def test_is_tree(self):
    def test_is_not_tree(self):
    def test_is_forest(self):
    def test_is_not_forest(self):
class TestDirectedTreeRecognition(TestTreeRecognition):
def test_disconnected_graph():
def test_dag_nontree():
def test_multicycle():
def test_emptybranch():
def test_path():
def test_notbranching1():
def test_notbranching2():
def test_notarborescence1():
def test_notarborescence2():

algorithms/tree/branchings.py
def random_string(L=15, seed=None):
def _min_weight(weight):
def _max_weight(weight):
def branching_weight(G, attr="weight", default=1):
def greedy_branching(G, attr="weight", default=1, kind="max", seed=None):
class MultiDiGraph_EdgeKey(nx.MultiDiGraph):
    def __init__(self, incoming_graph_data=None, **attr):
    def remove_node(self, n):
    def remove_nodes_from(self, nbunch):
    def add_edge(self, u_for_edge, v_for_edge, key_for_edge, **attr):
    def add_edges_from(self, ebunch_to_add, **attr):
    def remove_edge_with_key(self, key):
    def remove_edges_from(self, ebunch):
def get_path(G, u, v):
    def first_key(i, vv):
class Edmonds:
    def __init__(self, G, seed=None):
    def _init(self, attr, default, kind, style, preserve_attrs, seed, partition):
    def find_optimum(
        def desired_edge(v):
        def is_root(G, u, edgekeys):
def maximum_branching(
def minimum_branching(
def maximum_spanning_arborescence(
def minimum_spanning_arborescence(
class ArborescenceIterator:
    class Partition:
        def __copy__(self):
    def __init__(self, G, weight="weight", minimum=True, init_partition=None):
    def __iter__(self):
    def __next__(self):
    def _partition(self, partition, partition_arborescence):
    def _write_partition(self, partition):
    def _clear_partition(self, G):

algorithms/tree/coding.py
class NotATree(nx.NetworkXException):
def to_nested_tuple(T, root, canonical_form=False):
    def _make_tuple(T, root, _parent):
def from_nested_tuple(sequence, sensible_relabeling=False):
    def _make_tree(sequence):
def to_prufer_sequence(T):
    def parents(u):
def from_prufer_sequence(sequence):

algorithms/tree/recognition.py
def is_arborescence(G):
def is_branching(G):
def is_forest(G):
def is_tree(G):

algorithms/isomorphism/matchhelpers.py
def copyfunc(f, name=None):
def allclose(x, y, rtol=1.0000000000000001e-05, atol=1e-08):
def categorical_node_match(attr, default):
        def match(data1, data2):
        def match(data1, data2):
def categorical_multiedge_match(attr, default):
        def match(datasets1, datasets2):
        def match(datasets1, datasets2):
def numerical_node_match(attr, default, rtol=1.0000000000000001e-05, atol=1e-08):
        def match(data1, data2):
        def match(data1, data2):
def numerical_multiedge_match(attr, default, rtol=1.0000000000000001e-05, atol=1e-08):
        def match(datasets1, datasets2):
        def match(datasets1, datasets2):
def generic_node_match(attr, default, op):
        def match(data1, data2):
        def match(data1, data2):
def generic_multiedge_match(attr, default, op):
    def match(datasets1, datasets2):

algorithms/isomorphism/vf2userfunc.py
def _semantic_feasibility(self, G1_node, G2_node):
class GraphMatcher(vf2.GraphMatcher):
    def __init__(self, G1, G2, node_match=None, edge_match=None):
class DiGraphMatcher(vf2.DiGraphMatcher):
    def __init__(self, G1, G2, node_match=None, edge_match=None):
    def semantic_feasibility(self, G1_node, G2_node):
class MultiGraphMatcher(GraphMatcher):
class MultiDiGraphMatcher(DiGraphMatcher):

algorithms/isomorphism/isomorphvf2.py
class GraphMatcher:
    def __init__(self, G1, G2):
    def reset_recursion_limit(self):
    def candidate_pairs_iter(self):
    def initialize(self):
    def is_isomorphic(self):
    def isomorphisms_iter(self):
    def match(self):
    def semantic_feasibility(self, G1_node, G2_node):
    def subgraph_is_isomorphic(self):
    def subgraph_is_monomorphic(self):
    def subgraph_isomorphisms_iter(self):
    def subgraph_monomorphisms_iter(self):
    def syntactic_feasibility(self, G1_node, G2_node):
class DiGraphMatcher(GraphMatcher):
    def __init__(self, G1, G2):
    def candidate_pairs_iter(self):
    def initialize(self):
    def syntactic_feasibility(self, G1_node, G2_node):
class GMState:
    def __init__(self, GM, G1_node=None, G2_node=None):
    def restore(self):
class DiGMState:
    def __init__(self, GM, G1_node=None, G2_node=None):
    def restore(self):

algorithms/isomorphism/tests/test_isomorphism.py
class TestIsomorph:
    def setup_class(cls):
    def test_could_be_isomorphic(self):
    def test_fast_could_be_isomorphic(self):
    def test_faster_could_be_isomorphic(self):
    def test_is_isomorphic(self):

algorithms/isomorphism/tree_isomorphism.py
def root_trees(t1, root1, t2, root2):
def assign_levels(G, root):
def group_by_levels(levels):
def generate_isomorphism(v, w, M, ordered_children):
def rooted_tree_isomorphism(t1, root1, t2, root2):
def tree_isomorphism(t1, t2):

algorithms/isomorphism/tests/test_tree_isomorphism.py
def check_isomorphism(t1, t2, isomorphism):
def test_hardcoded():
def random_swap(t):
def positive_single_tree(t1):
def test_positive(maxk=14):
def test_trivial():
def test_trivial_2():
def test_negative(maxk=11):

algorithms/isomorphism/ismags.py
def are_all_equal(iterable):
def make_partitions(items, test):
def partition_to_color(partitions):
def intersect(collection_of_sets):
class ISMAGS:
    def __init__(self, graph, subgraph, node_match=None, edge_match=None, cache=None):
    def _sgn_partitions(self):
            def nodematch(node1, node2):
    def _sge_partitions(self):
            def edgematch(edge1, edge2):
    def _gn_partitions(self):
            def nodematch(node1, node2):
    def _ge_partitions(self):
            def edgematch(edge1, edge2):
    def _sgn_colors(self):
    def _sge_colors(self):
    def _gn_colors(self):
    def _ge_colors(self):
    def _node_compatibility(self):
    def _edge_compatibility(self):
    def _node_match_maker(cmp):
        def comparer(graph1, node1, graph2, node2):
    def _edge_match_maker(cmp):
        def comparer(graph1, edge1, graph2, edge2):
    def find_isomorphisms(self, symmetry=True):
    def _find_neighbor_color_count(graph, node, node_color, edge_color):
    def _get_lookahead_candidates(self):
    def largest_common_subgraph(self, symmetry=True):
    def analyze_symmetry(self, graph, node_partitions, edge_colors):
    def is_isomorphic(self, symmetry=False):
    def subgraph_is_isomorphic(self, symmetry=False):
    def isomorphisms_iter(self, symmetry=True):
    def subgraph_isomorphisms_iter(self, symmetry=True):
    def _find_nodecolor_candidates(self):
    def _make_constraints(cosets):
    def _find_node_edge_color(graph, node_colors, edge_colors):
    def _get_permutations_by_length(items):
    def _refine_node_partitions(cls, graph, node_partitions, edge_colors, branch=False):
        def equal_color(node1, node2):
    def _edges_of_same_color(self, sgn1, sgn2):
    def _map_nodes(self, sgn, candidates, constraints, mapping=None, to_be_mapped=None):
    def _largest_common_subgraph(self, candidates, constraints, to_be_mapped=None):
    def _remove_node(node, nodes, constraints):
    def _find_permutations(top_partitions, bottom_partitions):
    def _update_orbits(orbits, permutations):
    def _couple_nodes(
    def _process_ordered_pair_partitions(

algorithms/isomorphism/tests/test_temporalisomorphvf2.py
def provide_g1_edgelist():
def put_same_time(G, att_name):
def put_same_datetime(G, att_name):
def put_sequence_time(G, att_name):
def put_time_config_0(G, att_name):
def put_time_config_1(G, att_name):
def put_time_config_2(G, att_name):
class TestTimeRespectingGraphMatcher:
    def provide_g1_topology(self):
    def provide_g2_path_3edges(self):
    def test_timdelta_zero_timeRespecting_returnsTrue(self):
    def test_timdelta_zero_datetime_timeRespecting_returnsTrue(self):
    def test_attNameStrange_timdelta_zero_timeRespecting_returnsTrue(self):
    def test_notTimeRespecting_returnsFalse(self):
    def test_timdelta_one_config0_returns_no_embeddings(self):
    def test_timdelta_one_config1_returns_four_embedding(self):
    def test_timdelta_one_config2_returns_ten_embeddings(self):
class TestDiTimeRespectingGraphMatcher:
    def provide_g1_topology(self):
    def provide_g2_path_3edges(self):
    def test_timdelta_zero_same_dates_returns_true(self):
    def test_attNameStrange_timdelta_zero_same_dates_returns_true(self):
    def test_timdelta_one_config0_returns_no_embeddings(self):
    def test_timdelta_one_config1_returns_one_embedding(self):
    def test_timdelta_one_config2_returns_two_embeddings(self):

algorithms/isomorphism/tests/test_ismags.py
def _matches_to_sets(matches):
class TestSelfIsomorphism:
    def test_self_isomorphism(self):
    def test_edgecase_self_isomorphism(self):
    def test_directed_self_isomorphism(self):
class TestSubgraphIsomorphism:
    def test_isomorphism(self):
    def test_isomorphism2(self):
    def test_labeled_nodes(self):
    def test_labeled_edges(self):
class TestWikipediaExample:
    def test_graph(self):
class TestLargestCommonSubgraph:
    def test_mcis(self):
    def test_symmetry_mcis(self):

algorithms/isomorphism/tests/test_match_helpers.py
def test_categorical_node_match():
class TestGenericMultiEdgeMatch:
    def setup(self):
    def test_generic_multiedge_match(self):

algorithms/isomorphism/tests/test_isomorphvf2.py
class TestWikipediaExample:
    def test_graph(self):
    def test_subgraph(self):
    def test_subgraph_mono(self):
class TestVF2GraphDB:
    def create_graph(filename):
    def test_graph(self):
    def test_subgraph(self):
class TestAtlas:
    def setup_class(cls):
    def test_graph_atlas(self):
def test_multiedge():
def test_selfloop():
def test_selfloop_mono():
def test_isomorphism_iter1():
def test_monomorphism_iter1():
def test_isomorphism_iter2():
def test_multiple():
def test_noncomparable_nodes():
def test_monomorphism_edge_match():

tests/test_lazy_imports.py
def test_lazy_import_basics():
def test_lazy_import_impact_on_sys_modules():
def test_lazy_import_nonbuiltins():
def test_lazy_attach():

tests/test_relabel.py
class TestRelabel:
    def test_convert_node_labels_to_integers(self):
    def test_convert_to_integers2(self):
    def test_convert_to_integers_raise(self):
    def test_relabel_nodes_copy(self):
    def test_relabel_nodes_function(self):
        def mapping(n):
    def test_relabel_nodes_graph(self):
    def test_relabel_nodes_orderedgraph(self):
    def test_relabel_nodes_digraph(self):
    def test_relabel_nodes_multigraph(self):
    def test_relabel_nodes_multidigraph(self):
    def test_relabel_isolated_nodes_to_same(self):
    def test_relabel_nodes_missing(self):
    def test_relabel_copy_name(self):
    def test_relabel_toposort(self):
    def test_relabel_selfloop(self):
    def test_relabel_multidigraph_inout_merge_nodes(self):
    def test_relabel_multigraph_merge_inplace(self):
    def test_relabel_multidigraph_merge_inplace(self):
    def test_relabel_multidigraph_inout_copy(self):
    def test_relabel_multigraph_merge_copy(self):
    def test_relabel_multidigraph_merge_copy(self):
    def test_relabel_multigraph_nonnumeric_key(self):
    def test_relabel_circular(self):

tests/test_convert_numpy.py
def test_to_numpy_matrix_deprecation():
def test_from_numpy_matrix_deprecation():
def test_to_numpy_recarray_deprecation():
class TestConvertNumpyMatrix:
    def setup_method(self):
    def test_exceptions(self):
    def create_weighted(self, G):
    def assert_equal(self, G1, G2):
    def identity_conversion(self, G, A, create_using):
    def test_shape(self):
    def test_identity_graph_matrix(self):
    def test_identity_graph_array(self):
    def test_identity_digraph_matrix(self):
    def test_identity_digraph_array(self):
    def test_identity_weighted_graph_matrix(self):
    def test_identity_weighted_graph_array(self):
    def test_identity_weighted_digraph_matrix(self):
    def test_identity_weighted_digraph_array(self):
    def test_nodelist(self):
    def test_weight_keyword(self):
    def test_from_numpy_matrix_type(self):
    def test_from_numpy_matrix_dtype(self):
    def test_to_numpy_recarray(self):
    def test_numpy_multigraph(self):
    def test_from_numpy_matrix_parallel_edges(self):
    def test_symmetric(self):
    def test_dtype_int_graph(self):
    def test_dtype_int_multigraph(self):
class TestConvertNumpyArray:
    def setup_method(self):
    def create_weighted(self, G):
    def assert_equal(self, G1, G2):
    def identity_conversion(self, G, A, create_using):
    def test_shape(self):
    def test_identity_graph_array(self):
    def test_identity_digraph_array(self):
    def test_identity_weighted_graph_array(self):
    def test_identity_weighted_digraph_array(self):
    def test_nodelist(self):
    def test_weight_keyword(self):
    def test_from_numpy_array_type(self):
    def test_from_numpy_array_dtype(self):
    def test_from_numpy_array_parallel_edges(self):
    def test_symmetric(self):
    def test_dtype_int_graph(self):
    def test_dtype_int_multigraph(self):
def recarray_test_graph():
def test_to_numpy_recarray(recarray_test_graph):
def test_to_numpy_recarray_default_dtype(recarray_test_graph):
def test_to_numpy_recarray_directed(recarray_test_graph):
def test_to_numpy_recarray_default_dtype_no_weight():
def recarray_nodelist_test_graph():
def test_to_numpy_recarray_nodelist(recarray_nodelist_test_graph):
def test_to_numpy_recarray_bad_nodelist(recarray_nodelist_test_graph, nodelist, errmsg):
def multigraph_test_graph():
def test_numpy_multigraph(multigraph_test_graph, operator, expected):
def test_to_numpy_array_multigraph_nodelist(multigraph_test_graph):
def test_to_numpy_array_complex_weights(G, expected):
def test_to_numpy_array_arbitrary_weights():
def test_to_numpy_array_multiweight_reduction(func, expected):
def test_to_numpy_array_structured_dtype_attrs_from_fields(G, expected):
def test_to_numpy_array_structured_dtype_single_attr_default():
def test_to_numpy_array_structured_dtype_single_attr(field_name, expected_attr_val):
def test_to_numpy_array_structured_dtype_multiple_fields(graph_type, edge):
def test_to_numpy_array_structured_dtype_scalar_nonedge(G):
def test_to_numpy_array_structured_dtype_nonedge_ary(G):
def test_to_numpy_array_structured_dtype_with_weight_raises():
def test_to_numpy_array_structured_multigraph_raises(graph_type):

tests/test_convert_pandas.py
class TestConvertPandas:
    def setup_method(self):
    def test_exceptions(self):
    def test_from_edgelist_all_attr(self):
    def test_from_edgelist_multi_attr(self):
    def test_from_edgelist_multi_attr_incl_target(self):
    def test_from_edgelist_multidigraph_and_edge_attr(self):
    def test_from_edgelist_one_attr(self):
    def test_from_edgelist_int_attr_name(self):
    def test_from_edgelist_invalid_attr(self):
    def test_from_edgelist_no_attr(self):
    def test_from_edgelist(self):
    def test_to_edgelist_default_source_or_target_col_exists(self):
    def test_to_edgelist_custom_source_or_target_col_exists(self):
    def test_to_edgelist_edge_key_col_exists(self):
    def test_from_adjacency(self):
    def test_roundtrip(self, graph):
    def test_from_adjacency_named(self):
    def test_edgekey_with_multigraph(self):
    def test_edgekey_with_normal_graph_no_action(self):
    def test_nonexisting_edgekey_raises(self):
def test_to_pandas_adjacency_with_nodelist():
def test_to_pandas_edgelist_with_nodelist():

algorithms/isomorphism/tests/test_vf2userfunc.py
def test_simple():
def test_weightkey():
class TestNodeMatch_Graph:
    def setup_method(self):
    def build(self):
    def test_noweight_nocolor(self):
    def test_color1(self):
    def test_color2(self):
    def test_weight1(self):
    def test_weight2(self):
    def test_colorsandweights1(self):
    def test_colorsandweights2(self):
    def test_colorsandweights3(self):
class TestEdgeMatch_MultiGraph:
    def setup_method(self):
    def build(self):
    def test_weights_only(self):
    def test_colors_only(self):
    def test_colorsandweights(self):
    def test_generic1(self):
    def test_generic2(self):
class TestEdgeMatch_DiGraph(TestNodeMatch_Graph):
    def setup_method(self):
class TestEdgeMatch_MultiDiGraph(TestEdgeMatch_MultiGraph):
    def setup_method(self):

exception.py
class NetworkXException(Exception):
class NetworkXError(NetworkXException):
class NetworkXPointlessConcept(NetworkXException):
class NetworkXAlgorithmError(NetworkXException):
class NetworkXUnfeasible(NetworkXAlgorithmError):
class NetworkXNoPath(NetworkXUnfeasible):
class NetworkXNoCycle(NetworkXUnfeasible):
class HasACycle(NetworkXException):
class NetworkXUnbounded(NetworkXAlgorithmError):
class NetworkXNotImplemented(NetworkXException):
class NodeNotFound(NetworkXException):
class AmbiguousSolution(NetworkXException):
class ExceededMaxIterations(NetworkXException):
class PowerIterationFailedConvergence(ExceededMaxIterations):
    def __init__(self, num_iterations, *args, **kw):

relabel.py
def relabel_nodes(G, mapping, copy=True):
def _relabel_inplace(G, mapping):
def _relabel_copy(G, mapping):
def convert_node_labels_to_integers(

linalg/attrmatrix.py
def _node_value(G, node_attr):
        def value(u):
        def value(u):
def _edge_value(G, edge_attr):
            def value(u, v):
            def value(u, v):
                def value(u, v):
                def value(u, v):
                def value(u, v):
                def value(u, v):
def attr_matrix(
def attr_sparse_matrix(

classes/filters.py
def no_filter(*items):
def hide_nodes(nodes):
def hide_diedges(edges):
def hide_edges(edges):
def hide_multidiedges(edges):
def hide_multiedges(edges):
class show_nodes:
    def __init__(self, nodes):
    def __call__(self, node):
def show_diedges(edges):
def show_edges(edges):
def show_multidiedges(edges):
def show_multiedges(edges):

classes/graphviews.py
def generic_graph_view(G, create_using=None):
def subgraph_view(G, filter_node=no_filter, filter_edge=no_filter):
        def reverse_edge(u, v, k=None):
        def reverse_edge(u, v, k=None):
def reverse_view(G):

linalg/spectrum.py
def laplacian_spectrum(G, weight="weight"):
def normalized_laplacian_spectrum(G, weight="weight"):
def adjacency_spectrum(G, weight="weight"):
def modularity_spectrum(G):
def bethe_hessian_spectrum(G, r=None):

classes/function.py
def nodes(G):
def edges(G, nbunch=None):
def degree(G, nbunch=None, weight=None):
def neighbors(G, n):
def number_of_nodes(G):
def number_of_edges(G):
def density(G):
def degree_histogram(G):
def is_directed(G):
def frozen(*args, **kwargs):
def freeze(G):
def is_frozen(G):
def add_star(G_to_add_to, nodes_for_star, **attr):
def add_path(G_to_add_to, nodes_for_path, **attr):
def add_cycle(G_to_add_to, nodes_for_cycle, **attr):
def subgraph(G, nbunch):
def induced_subgraph(G, nbunch):
def edge_subgraph(G, edges):
def restricted_view(G, nodes, edges):
def to_directed(graph):
def to_undirected(graph):
def create_empty_copy(G, with_data=True):
def info(G, n=None):
def set_node_attributes(G, values, name=None):
def get_node_attributes(G, name):
def set_edge_attributes(G, values, name=None):
def get_edge_attributes(G, name):
def all_neighbors(graph, node):
def non_neighbors(graph, node):
def non_edges(graph):
def common_neighbors(G, u, v):
def is_weighted(G, edge=None, weight="weight"):
def is_negatively_weighted(G, edge=None, weight="weight"):
def is_empty(G):
def nodes_with_selfloops(G):
def selfloop_edges(G, data=False, keys=False, default=None):
def number_of_selfloops(G):
def is_path(G, path):
def path_weight(G, path, weight):

classes/ordered.py
class OrderedGraph(Graph):
    def __init__(self, incoming_graph_data=None, **attr):
class OrderedDiGraph(DiGraph):
    def __init__(self, incoming_graph_data=None, **attr):
class OrderedMultiGraph(MultiGraph):
    def __init__(self, incoming_graph_data=None, **attr):
class OrderedMultiDiGraph(MultiDiGraph):
    def __init__(self, incoming_graph_data=None, **attr):

linalg/modularitymatrix.py
def modularity_matrix(G, nodelist=None, weight=None):
def directed_modularity_matrix(G, nodelist=None, weight=None):

linalg/graphmatrix.py
def incidence_matrix(G, nodelist=None, edgelist=None, oriented=False, weight=None):
def adjacency_matrix(G, nodelist=None, dtype=None, weight="weight"):
def _adj_matrix_warning(G, nodelist=None, dtype=None, weight="weight"):

classes/multidigraph.py
class MultiDiGraph(MultiGraph, DiGraph):
    def __init__(self, incoming_graph_data=None, multigraph_input=None, **attr):
    def adj(self):
    def succ(self):
    def pred(self):
    def add_edge(self, u_for_edge, v_for_edge, key=None, **attr):
    def remove_edge(self, u, v, key=None):
    def edges(self):
    def in_edges(self):
    def degree(self):
    def in_degree(self):
    def out_degree(self):
    def is_multigraph(self):
    def is_directed(self):
    def to_undirected(self, reciprocal=False, as_view=False):
    def reverse(self, copy=True):

classes/digraph.py
class DiGraph(Graph):
    def __init__(self, incoming_graph_data=None, **attr):
    def adj(self):
    def succ(self):
    def pred(self):
    def add_node(self, node_for_adding, **attr):
    def add_nodes_from(self, nodes_for_adding, **attr):
    def remove_node(self, n):
    def remove_nodes_from(self, nodes):
    def add_edge(self, u_of_edge, v_of_edge, **attr):
    def add_edges_from(self, ebunch_to_add, **attr):
    def remove_edge(self, u, v):
    def remove_edges_from(self, ebunch):
    def has_successor(self, u, v):
    def has_predecessor(self, u, v):
    def successors(self, n):
    def predecessors(self, n):
    def edges(self):
    def in_edges(self):
    def degree(self):
    def in_degree(self):
    def out_degree(self):
    def clear(self):
    def clear_edges(self):
    def is_multigraph(self):
    def is_directed(self):
    def to_undirected(self, reciprocal=False, as_view=False):
    def reverse(self, copy=True):

linalg/tests/test_spectrum.py
class TestSpectrum:
    def setup_class(cls):
    def test_laplacian_spectrum(self):
    def test_normalized_laplacian_spectrum(self):
    def test_adjacency_spectrum(self):
    def test_modularity_spectrum(self):
    def test_bethe_hessian_spectrum(self):

classes/multigraph.py
class MultiGraph(Graph):
    def to_directed_class(self):
    def to_undirected_class(self):
    def __init__(self, incoming_graph_data=None, multigraph_input=None, **attr):
    def adj(self):
    def new_edge_key(self, u, v):
    def add_edge(self, u_for_edge, v_for_edge, key=None, **attr):
    def add_edges_from(self, ebunch_to_add, **attr):
    def remove_edge(self, u, v, key=None):
    def remove_edges_from(self, ebunch):
    def has_edge(self, u, v, key=None):
    def edges(self):
    def get_edge_data(self, u, v, key=None, default=None):
    def degree(self):
    def is_multigraph(self):
    def is_directed(self):
    def copy(self, as_view=False):
    def to_directed(self, as_view=False):
    def to_undirected(self, as_view=False):
    def number_of_edges(self, u=None, v=None):

classes/reportviews.py
class NodeView(Mapping, Set):
    def __getstate__(self):
    def __setstate__(self, state):
    def __init__(self, graph):
    def __len__(self):
    def __iter__(self):
    def __getitem__(self, n):
    def __contains__(self, n):
    def _from_iterable(cls, it):
    def __call__(self, data=False, default=None):
    def data(self, data=True, default=None):
    def __str__(self):
    def __repr__(self):
class NodeDataView(Set):
    def __getstate__(self):
    def __setstate__(self, state):
    def __init__(self, nodedict, data=False, default=None):
    def _from_iterable(cls, it):
    def __len__(self):
    def __iter__(self):
    def __contains__(self, n):
    def __getitem__(self, n):
    def __str__(self):
    def __repr__(self):
class DiDegreeView:
    def __init__(self, G, nbunch=None, weight=None):
    def __call__(self, nbunch=None, weight=None):
    def __getitem__(self, n):
    def __iter__(self):
    def __len__(self):
    def __str__(self):
    def __repr__(self):
class DegreeView(DiDegreeView):
    def __getitem__(self, n):
    def __iter__(self):
class OutDegreeView(DiDegreeView):
    def __getitem__(self, n):
    def __iter__(self):
class InDegreeView(DiDegreeView):
    def __getitem__(self, n):
    def __iter__(self):
class MultiDegreeView(DiDegreeView):
    def __getitem__(self, n):
    def __iter__(self):
class DiMultiDegreeView(DiDegreeView):
    def __getitem__(self, n):
    def __iter__(self):
class InMultiDegreeView(DiDegreeView):
    def __getitem__(self, n):
    def __iter__(self):
class OutMultiDegreeView(DiDegreeView):
    def __getitem__(self, n):
    def __iter__(self):
class OutEdgeDataView:
    def __getstate__(self):
    def __setstate__(self, state):
    def __init__(self, viewer, nbunch=None, data=False, default=None):
    def __len__(self):
    def __iter__(self):
    def __contains__(self, e):
    def __str__(self):
    def __repr__(self):
class EdgeDataView(OutEdgeDataView):
    def __len__(self):
    def __iter__(self):
    def __contains__(self, e):
class InEdgeDataView(OutEdgeDataView):
    def __iter__(self):
    def __contains__(self, e):
class OutMultiEdgeDataView(OutEdgeDataView):
    def __getstate__(self):
    def __setstate__(self, state):
    def __init__(self, viewer, nbunch=None, data=False, keys=False, default=None):
    def __len__(self):
    def __iter__(self):
    def __contains__(self, e):
class MultiEdgeDataView(OutMultiEdgeDataView):
    def __iter__(self):
    def __contains__(self, e):
class InMultiEdgeDataView(OutMultiEdgeDataView):
    def __iter__(self):
    def __contains__(self, e):
class OutEdgeView(Set, Mapping):
    def __getstate__(self):
    def __setstate__(self, state):
    def _from_iterable(cls, it):
    def __init__(self, G):
    def __len__(self):
    def __iter__(self):
    def __contains__(self, e):
    def __getitem__(self, e):
    def __call__(self, nbunch=None, data=False, default=None):
    def data(self, data=True, default=None, nbunch=None):
    def __str__(self):
    def __repr__(self):
class EdgeView(OutEdgeView):
    def __len__(self):
    def __iter__(self):
    def __contains__(self, e):
class InEdgeView(OutEdgeView):
    def __setstate__(self, state):
    def __init__(self, G):
    def __iter__(self):
    def __contains__(self, e):
    def __getitem__(self, e):
class OutMultiEdgeView(OutEdgeView):
    def __len__(self):
    def __iter__(self):
    def __contains__(self, e):
    def __getitem__(self, e):
    def __call__(self, nbunch=None, data=False, keys=False, default=None):
    def data(self, data=True, keys=False, default=None, nbunch=None):
class MultiEdgeView(OutMultiEdgeView):
    def __len__(self):
    def __iter__(self):
class InMultiEdgeView(OutMultiEdgeView):
    def __setstate__(self, state):
    def __init__(self, G):
    def __iter__(self):
    def __contains__(self, e):
    def __getitem__(self, e):

linalg/tests/test_bethehessian.py
class TestBetheHessian:
    def setup_class(cls):
    def test_bethe_hessian(self):

linalg/tests/test_graphmatrix.py
def test_incidence_matrix_simple():
class TestGraphMatrix:
    def setup_class(cls):
    def test_incidence_matrix(self):
    def test_weighted_incidence_matrix(self):
    def test_adjacency_matrix(self):

linalg/tests/test_modularity.py
class TestModularity:
    def setup_class(cls):
    def test_modularity(self):
    def test_modularity_weight(self):
    def test_directed_modularity(self):

linalg/tests/test_laplacian.py
class TestLaplacian:
    def setup_class(cls):
    def test_laplacian(self):
    def test_normalized_laplacian(self):
def test_directed_laplacian():
def test_directed_combinatorial_laplacian():

linalg/tests/test_attrmatrix.py
def test_attr_matrix():
    def node_attr(u):
    def edge_attr(u, v):
def test_attr_matrix_directed():
def test_attr_matrix_multigraph():
def test_attr_sparse_matrix():
def test_attr_sparse_matrix_directed():

linalg/tests/test_algebraic_connectivity.py
def test_algebraic_connectivity_tracemin_chol():
def test_fiedler_vector_tracemin_chol():
def test_spectral_ordering_tracemin_chol():
def test_fiedler_vector_tracemin_unknown():
def check_eigenvector(A, l, x):
class TestAlgebraicConnectivity:
    def test_directed(self, method):
    def test_null_and_singleton(self, method):
    def test_disconnected(self, method):
    def test_unrecognized_method(self):
    def test_two_nodes(self, method):
    def test_two_nodes_multigraph(self, method):
    def test_abbreviation_of_method(self):
    def test_path(self, method):
    def test_problematic_graph_issue_2381(self, method):
    def test_cycle(self, method):
    def test_seed_argument(self, method):
    def test_buckminsterfullerene(self, normalized, sigma, laplacian_fn, method):
class TestSpectralOrdering:
    def test_nullgraph(self, graph):
    def test_singleton(self, graph):
    def test_unrecognized_method(self):
    def test_three_nodes(self, method):
    def test_three_nodes_multigraph(self, method):
    def test_path(self, method):
    def test_seed_argument(self, method):
    def test_disconnected(self, method):
    def test_cycle(self, normalized, expected_order, method):

linalg/laplacianmatrix.py
def laplacian_matrix(G, nodelist=None, weight="weight"):
def normalized_laplacian_matrix(G, nodelist=None, weight="weight"):
def directed_laplacian_matrix(
def directed_combinatorial_laplacian_matrix(
def _transition_matrix(G, nodelist=None, weight="weight", walk_type=None, alpha=0.95):

classes/tests/test_ordered.py
class TestOrdered:
    def test_graph(self):
    def test_digraph(self):
    def test_multigraph(self):
    def test_multidigraph(self):
class TestOrderedFeatures:
    def setup_class(cls):
    def test_subgraph_order(self):

classes/tests/test_graph_historical.py
class TestGraphHistorical(HistoricalTests):
    def setup_class(cls):

classes/tests/test_digraph.py
class BaseDiGraphTester(BaseGraphTester):
    def test_has_successor(self):
    def test_successors(self):
    def test_has_predecessor(self):
    def test_predecessors(self):
    def test_edges(self):
    def test_out_edges(self):
    def test_out_edges_dir(self):
    def test_out_edges_data(self):
    def test_in_edges_dir(self):
    def test_in_edges_data(self):
    def test_degree(self):
    def test_in_degree(self):
    def test_out_degree(self):
    def test_size(self):
    def test_to_undirected_reciprocal(self):
    def test_reverse_copy(self):
    def test_reverse_nocopy(self):
    def test_reverse_hashable(self):
        class Foo:
class BaseAttrDiGraphTester(BaseDiGraphTester, BaseAttrGraphTester):
    def test_edges_data(self):
    def test_in_degree_weighted(self):
    def test_out_degree_weighted(self):
class TestDiGraph(BaseAttrDiGraphTester, _TestGraph):
    def setup_method(self):
    def test_data_input(self):
    def test_add_edge(self):
    def test_add_edges_from(self):
    def test_remove_edge(self):
    def test_remove_edges_from(self):
    def test_clear(self):
    def test_clear_edges(self):
class TestEdgeSubgraph(_TestGraphEdgeSubgraph):
    def setup_method(self):
    def test_pred_succ(self):

classes/tests/test_subgraphviews.py
class TestSubGraphView:
    def setup_class(cls):
    def test_hidden_nodes(self):
    def test_hidden_edges(self):
    def test_shown_node(self):
    def test_shown_edges(self):
class TestSubDiGraphView(TestSubGraphView):
    def test_inoutedges(self):
    def test_pred(self):
    def test_inout_degree(self):
class TestMultiGraphView(TestSubGraphView):
    def setup_class(cls):
    def test_hidden_edges(self):
    def test_shown_edges(self):
class TestMultiDiGraphView(TestMultiGraphView, TestSubDiGraphView):
    def test_inout_degree(self):
class TestInducedSubGraph:
    def setup_class(cls):
    def test_full_graph(self):
    def test_partial_subgraph(self):
    def same_attrdict(self, H, G):
    def graphs_equal(self, H, G):
class TestEdgeSubGraph:
    def setup_class(cls):
    def test_correct_nodes(self):
    def test_correct_edges(self):
    def test_add_node(self):
    def test_remove_node(self):
    def test_node_attr_dict(self):
    def test_edge_attr_dict(self):
    def test_graph_attr_dict(self):
    def test_readonly(self):

classes/tests/test_graph.py
class BaseGraphTester:
    def test_contains(self):
    def test_order(self):
    def test_nodes(self):
    def test_none_node(self):
    def test_has_node(self):
    def test_has_edge(self):
    def test_neighbors(self):
    def test_memory_leak(self):
        def count_objects_of_type(_type):
        class MyGraph(self.Graph):
    def test_edges(self):
    def test_degree(self):
    def test_size(self):
    def test_nbunch_iter(self):
    def test_nbunch_iter_node_format_raise(self):
    def test_selfloop_degree(self):
    def test_selfloops(self):
class BaseAttrGraphTester(BaseGraphTester):
    def test_weighted_degree(self):
    def add_attributes(self, G):
    def test_name(self):
    def test_str_unnamed(self):
    def test_str_named(self):
    def test_graph_chain(self):
    def test_copy(self):
    def test_class_copy(self):
    def test_fresh_copy(self):
    def is_deepcopy(self, H, G):
    def deep_copy_attrdict(self, H, G):
    def deepcopy_graph_attr(self, H, G):
    def deepcopy_node_attr(self, H, G):
    def deepcopy_edge_attr(self, H, G):
    def is_shallow_copy(self, H, G):
    def shallow_copy_attrdict(self, H, G):
    def shallow_copy_graph_attr(self, H, G):
    def shallow_copy_node_attr(self, H, G):
    def shallow_copy_edge_attr(self, H, G):
    def same_attrdict(self, H, G):
    def different_attrdict(self, H, G):
    def graphs_equal(self, H, G):
    def test_graph_attr(self):
    def test_node_attr(self):
    def test_node_attr2(self):
    def test_edge_lookup(self):
    def test_edge_attr(self):
    def test_edge_attr2(self):
    def test_edge_attr3(self):
    def test_edge_attr4(self):
    def test_to_undirected(self):
    def test_to_directed_as_view(self):
    def test_to_undirected_as_view(self):
    def test_directed_class(self):
        class newGraph(G.to_undirected_class()):
            def to_directed_class(self):
            def to_undirected_class(self):
        class newDiGraph(G.to_directed_class()):
            def to_directed_class(self):
            def to_undirected_class(self):
    def test_to_directed(self):
    def test_subgraph(self):
    def test_selfloops_attr(self):
class TestGraph(BaseAttrGraphTester):
    def setup_method(self):
    def test_pickle(self):
    def test_data_input(self):
    def test_adjacency(self):
    def test_getitem(self):
    def test_add_node(self):
    def test_add_nodes_from(self):
    def test_remove_node(self):
    def test_remove_nodes_from(self):
    def test_add_edge(self):
    def test_add_edges_from(self):
    def test_remove_edge(self):
    def test_remove_edges_from(self):
    def test_clear(self):
    def test_clear_edges(self):
    def test_edges_data(self):
    def test_get_edge_data(self):
    def test_update(self):
class TestEdgeSubgraph:
    def setup_method(self):
    def test_correct_nodes(self):
    def test_correct_edges(self):
    def test_add_node(self):
    def test_remove_node(self):
    def test_node_attr_dict(self):
    def test_edge_attr_dict(self):
    def test_graph_attr_dict(self):

classes/tests/test_filters.py
class TestFilterFactory:
    def test_no_filter(self):
    def test_hide_nodes(self):
    def test_show_nodes(self):
    def test_hide_edges(self):
    def test_show_edges(self):
    def test_hide_diedges(self):
    def test_show_diedges(self):
    def test_hide_multiedges(self):
    def test_show_multiedges(self):
    def test_hide_multidiedges(self):
    def test_show_multidiedges(self):

classes/tests/test_special.py
def test_factories():
    class mydict1(dict):
    class mydict2(dict):
    class mydict3(dict):
    class mydict4(dict):
    class mydict5(dict):
        class MyGraph(Graph):
class TestSpecialGraph(_TestGraph):
    def setup_method(self):
class TestOrderedGraph(_TestGraph):
    def setup_method(self):
        class MyGraph(nx.Graph):
class TestThinGraph(BaseGraphTester):
    def setup_method(self):
        class MyGraph(nx.Graph):
            def edge_attr_dict_factory(self):
class TestSpecialDiGraph(_TestDiGraph):
    def setup_method(self):
class TestOrderedDiGraph(_TestDiGraph):
    def setup_method(self):
        class MyGraph(nx.DiGraph):
class TestThinDiGraph(BaseDiGraphTester):
    def setup_method(self):
        class MyGraph(nx.DiGraph):
            def edge_attr_dict_factory(self):
class TestSpecialMultiGraph(_TestMultiGraph):
    def setup_method(self):
class TestOrderedMultiGraph(_TestMultiGraph):
    def setup_method(self):
        class MyGraph(nx.MultiGraph):
class TestSpecialMultiDiGraph(_TestMultiDiGraph):
    def setup_method(self):
class TestOrderedMultiDiGraph(_TestMultiDiGraph):
    def setup_method(self):
        class MyGraph(nx.MultiDiGraph):

classes/tests/test_function.py
class TestFunction:
    def setup_method(self):
    def test_nodes(self):
    def test_edges(self):
    def test_degree(self):
    def test_neighbors(self):
    def test_number_of_nodes(self):
    def test_number_of_edges(self):
    def test_is_directed(self):
    def test_add_star(self):
    def test_add_path(self):
    def test_add_cycle(self):
    def test_subgraph(self):
    def test_edge_subgraph(self):
    def test_create_empty_copy(self):
    def test_degree_histogram(self):
    def test_density(self):
    def test_density_selfloop(self):
    def test_freeze(self):
    def test_is_frozen(self):
    def test_info(self):
    def test_info_digraph(self):
    def test_neighbors_complete_graph(self):
    def test_non_neighbors(self):
    def test_non_edges(self):
    def test_is_weighted(self):
    def test_is_negatively_weighted(self):
class TestCommonNeighbors:
    def setup_class(cls):
        def test_func(G, u, v, expected):
    def test_K5(self):
    def test_P3(self):
    def test_S4(self):
    def test_digraph(self):
    def test_nonexistent_nodes(self):
    def test_custom1(self):
    def test_custom2(self):
def test_set_node_attributes(graph_type):
def test_set_node_attributes_ignores_extra_nodes(values, name):
def test_set_edge_attributes(graph_type):
def test_set_edge_attributes_ignores_extra_edges(values, name):
def test_set_edge_attributes_multi(graph_type):
def test_set_edge_attributes_multi_ignores_extra_edges(values, name):
def test_get_node_attributes():
def test_get_edge_attributes():
def test_is_empty():
def test_selfloops(graph_type):
def test_selfloop_edges_attr(graph_type):
def test_selfloop_edges_multi_with_data_and_keys():
def test_selfloops_removal(graph_type):
def test_selfloops_removal_multi(graph_type):
def test_pathweight():
def test_ispath():
def test_restricted_view(G):
def test_restricted_view_multi(G):

classes/tests/test_reportviews.py
class TestNodeView:
    def setup_class(cls):
    def test_pickle(self):
    def test_str(self):
    def test_repr(self):
    def test_contains(self):
    def test_getitem(self):
    def test_iter(self):
    def test_call(self):
class TestNodeDataView:
    def setup_class(cls):
    def test_viewtype(self):
    def test_pickle(self):
    def test_str(self):
    def test_repr(self):
    def test_contains(self):
    def test_getitem(self):
    def test_iter(self):
def test_nodedataview_unhashable():
class TestNodeViewSetOps:
    def setup_class(cls):
    def n_its(self, nodes):
    def test_len(self):
    def test_and(self):
    def test_or(self):
    def test_xor(self):
    def test_sub(self):
class TestNodeDataViewSetOps(TestNodeViewSetOps):
    def setup_class(cls):
    def n_its(self, nodes):
class TestNodeDataViewDefaultSetOps(TestNodeDataViewSetOps):
    def setup_class(cls):
    def n_its(self, nodes):
class TestEdgeDataView:
    def setup_class(cls):
    def test_pickle(self):
    def modify_edge(self, G, e, **kwds):
    def test_str(self):
    def test_repr(self):
    def test_iterdata(self):
    def test_iter(self):
    def test_contains(self):
    def test_contains_with_nbunch(self):
    def test_len(self):
class TestOutEdgeDataView(TestEdgeDataView):
    def setup_class(cls):
    def test_repr(self):
    def test_len(self):
    def test_contains_with_nbunch(self):
class TestInEdgeDataView(TestOutEdgeDataView):
    def setup_class(cls):
    def test_repr(self):
    def test_contains_with_nbunch(self):
class TestMultiEdgeDataView(TestEdgeDataView):
    def setup_class(cls):
    def modify_edge(self, G, e, **kwds):
    def test_repr(self):
    def test_contains_with_nbunch(self):
class TestOutMultiEdgeDataView(TestOutEdgeDataView):
    def setup_class(cls):
    def modify_edge(self, G, e, **kwds):
    def test_repr(self):
    def test_contains_with_nbunch(self):
class TestInMultiEdgeDataView(TestOutMultiEdgeDataView):
    def setup_class(cls):
    def test_repr(self):
    def test_contains_with_nbunch(self):
class TestEdgeView:
    def setup_class(cls):
    def test_pickle(self):
    def modify_edge(self, G, e, **kwds):
    def test_str(self):
    def test_repr(self):
    def test_getitem(self):
    def test_call(self):
    def test_data(self):
    def test_iter(self):
    def test_contains(self):
    def test_contains_with_nbunch(self):
    def test_len(self):
    def test_and(self):
    def test_or(self):
    def test_xor(self):
    def test_sub(self):
class TestOutEdgeView(TestEdgeView):
    def setup_class(cls):
    def test_repr(self):
    def test_contains_with_nbunch(self):
class TestInEdgeView(TestEdgeView):
    def setup_class(cls):
    def test_repr(self):
    def test_contains_with_nbunch(self):
class TestMultiEdgeView(TestEdgeView):
    def setup_class(cls):
    def modify_edge(self, G, e, **kwds):
    def test_str(self):
    def test_getitem(self):
    def test_repr(self):
    def test_call(self):
    def test_data(self):
    def test_iter(self):
    def test_iterkeys(self):
    def test_or(self):
    def test_sub(self):
    def test_xor(self):
    def test_and(self):
    def test_contains_with_nbunch(self):
class TestOutMultiEdgeView(TestMultiEdgeView):
    def setup_class(cls):
    def modify_edge(self, G, e, **kwds):
    def test_repr(self):
    def test_contains_with_nbunch(self):
class TestInMultiEdgeView(TestMultiEdgeView):
    def setup_class(cls):
    def modify_edge(self, G, e, **kwds):
    def test_repr(self):
    def test_contains_with_nbunch(self):
class TestDegreeView:
    def setup_class(cls):
    def test_pickle(self):
    def test_str(self):
    def test_repr(self):
    def test_iter(self):
    def test_nbunch(self):
    def test_getitem(self):
    def test_weight(self):
    def test_len(self):
class TestDiDegreeView(TestDegreeView):
    def test_repr(self):
class TestOutDegreeView(TestDegreeView):
    def test_str(self):
    def test_repr(self):
    def test_nbunch(self):
    def test_getitem(self):
    def test_weight(self):
class TestInDegreeView(TestDegreeView):
    def test_str(self):
    def test_repr(self):
    def test_nbunch(self):
    def test_getitem(self):
    def test_weight(self):
class TestMultiDegreeView(TestDegreeView):
    def test_str(self):
    def test_repr(self):
    def test_nbunch(self):
    def test_getitem(self):
    def test_weight(self):
class TestDiMultiDegreeView(TestMultiDegreeView):
    def test_repr(self):
class TestOutMultiDegreeView(TestDegreeView):
    def test_str(self):
    def test_repr(self):
    def test_nbunch(self):
    def test_getitem(self):
    def test_weight(self):
class TestInMultiDegreeView(TestDegreeView):
    def test_str(self):
    def test_repr(self):
    def test_nbunch(self):
    def test_getitem(self):
    def test_weight(self):
def test_slicing_reportviews(reportview, err_msg_terms):

classes/tests/test_multigraph.py
class BaseMultiGraphTester(BaseAttrGraphTester):
    def test_has_edge(self):
    def test_get_edge_data(self):
    def test_adjacency(self):
    def deepcopy_edge_attr(self, H, G):
    def shallow_copy_edge_attr(self, H, G):
    def graphs_equal(self, H, G):
    def same_attrdict(self, H, G):
    def different_attrdict(self, H, G):
    def test_to_undirected(self):
    def test_to_directed(self):
    def test_number_of_edges_selfloops(self):
    def test_edge_lookup(self):
    def test_edge_attr(self):
    def test_edge_attr4(self):
class TestMultiGraph(BaseMultiGraphTester, _TestGraph):
    def setup_method(self):
    def test_data_input(self):
    def test_data_multigraph_input(self):
    def test_non_multigraph_input(self, dod, mgi, edges):
    def test_non_multigraph_input_mgi_none(self, dod, edges):
    def test_non_multigraph_input_raise(self, dod):
    def test_getitem(self):
    def test_remove_node(self):
    def test_add_edge(self):
    def test_add_edge_conflicting_key(self):
    def test_add_edges_from(self):
    def test_remove_edge(self):
    def test_remove_edges_from(self):
    def test_remove_multiedge(self):
class TestEdgeSubgraph:
    def setup_method(self):
    def test_correct_nodes(self):
    def test_correct_edges(self):
    def test_add_node(self):
    def test_remove_node(self):
    def test_node_attr_dict(self):
    def test_edge_attr_dict(self):
    def test_graph_attr_dict(self):
def test_multigraph_add_edges_from_four_tuple_misordered():

classes/tests/test_coreviews.py
class TestAtlasView:
    def setup(self):
    def test_pickle(self):
    def test_len(self):
    def test_iter(self):
    def test_getitem(self):
    def test_copy(self):
    def test_items(self):
    def test_str(self):
    def test_repr(self):
class TestAdjacencyView:
    def setup(self):
    def test_pickle(self):
    def test_len(self):
    def test_iter(self):
    def test_getitem(self):
    def test_copy(self):
    def test_items(self):
    def test_str(self):
    def test_repr(self):
class TestMultiAdjacencyView(TestAdjacencyView):
    def setup(self):
    def test_getitem(self):
    def test_copy(self):
class TestUnionAtlas:
    def setup(self):
    def test_pickle(self):
    def test_len(self):
    def test_iter(self):
    def test_getitem(self):
    def test_copy(self):
    def test_items(self):
    def test_str(self):
    def test_repr(self):
class TestUnionAdjacency:
    def setup(self):
    def test_pickle(self):
    def test_len(self):
    def test_iter(self):
    def test_getitem(self):
    def test_copy(self):
    def test_str(self):
    def test_repr(self):
class TestUnionMultiInner(TestUnionAdjacency):
    def setup(self):
    def test_len(self):
    def test_getitem(self):
    def test_copy(self):
class TestUnionMultiAdjacency(TestUnionAdjacency):
    def setup(self):
    def test_getitem(self):
    def test_copy(self):
class TestFilteredGraphs:
    def setup(self):
    def test_hide_show_nodes(self):
    def test_str_repr(self):
    def test_copy(self):
    def test_filtered_copy(self):

classes/tests/test_digraph_historical.py
class TestDiGraphHistorical(HistoricalTests):
    def setup_class(cls):
    def test_in_degree(self):
    def test_out_degree(self):
    def test_degree_digraph(self):
    def test_neighbors(self):
    def test_successors(self):
    def test_predecessors(self):
    def test_reverse(self):
    def test_reverse2(self):
    def test_reverse3(self):

classes/tests/historical_tests.py
class HistoricalTests:
    def setup_class(cls):
    def test_name(self):
    def test_add_remove_node(self):
    def test_nonhashable_node(self):
    def test_add_nodes_from(self):
    def test_contains(self):
    def test_add_remove(self):
    def test_nbunch_is_list(self):
    def test_nbunch_is_set(self):
    def test_nbunch_dict(self):
    def test_nbunch_iterator(self):
    def test_nbunch_graph(self):
    def test_add_edge(self):
    def test_self_loop(self):
    def test_add_edges_from(self):
    def test_add_edges_from2(self):
    def test_add_edges_from3(self):
    def test_remove_edge(self):
    def test_edges_nbunch(self):
    def test_degree(self):
    def test_degree2(self):
    def test_degree_graph(self):
    def test_null(self):
    def test_order_size(self):
    def test_copy(self):
    def test_subgraph(self):
    def test_to_directed(self):
    def test_to_undirected(self):
    def test_neighbors(self):
    def test_iterators(self):
    def test_null_subgraph(self):
    def test_empty_subgraph(self):
    def test_complete_subgraph(self):
    def test_subgraph_nbunch(self):
    def test_node_tuple_issue(self):

classes/tests/test_graphviews.py
class TestReverseView:
    def setup(self):
    def test_pickle(self):
    def test_contains(self):
    def test_iter(self):
    def test_exceptions(self):
    def test_subclass(self):
        class MyGraph(nx.DiGraph):
            def my_method(self):
            def to_directed_class(self):
class TestMultiReverseView:
    def setup(self):
    def test_pickle(self):
    def test_contains(self):
    def test_iter(self):
    def test_exceptions(self):
def test_generic_multitype():
class TestToDirected:
    def setup(self):
    def test_directed(self):
    def test_already_directed(self):
    def test_pickle(self):
    def test_contains(self):
    def test_iter(self):
class TestToUndirected:
    def setup(self):
    def test_directed(self):
    def test_already_directed(self):
    def test_pickle(self):
    def test_contains(self):
    def test_iter(self):
class TestChainsOfViews:
    def setup_class(cls):
    def test_pickle(self):
    def test_subgraph_of_subgraph(self):
    def test_restricted_induced_subgraph_chains(self):
    def test_subgraph_copy(self):
    def test_subgraph_todirected(self):
    def test_subgraph_toundirected(self):
    def test_reverse_subgraph_toundirected(self):
    def test_reverse_reverse_copy(self):
    def test_subgraph_edgesubgraph_toundirected(self):
    def test_copy_subgraph(self):
    def test_copy_disubgraph(self):
    def test_copy_multidisubgraph(self):
    def test_copy_multisubgraph(self):
    def test_copy_of_view(self):
    def test_subclass(self):
        class MyGraph(nx.DiGraph):
            def my_method(self):
            def to_directed_class(self):

linalg/bethehessianmatrix.py
def bethe_hessian_matrix(G, r=None, nodelist=None):

classes/tests/test_multidigraph.py
class BaseMultiDiGraphTester(BaseMultiGraphTester):
    def test_edges(self):
    def test_edges_data(self):
    def test_edges_multi(self):
    def test_out_edges(self):
    def test_out_edges_multi(self):
    def test_out_edges_data(self):
    def test_in_edges(self):
    def test_in_edges_no_keys(self):
    def test_in_edges_data(self):
    def is_shallow(self, H, G):
    def is_deep(self, H, G):
    def test_to_undirected(self):
    def test_has_successor(self):
    def test_successors(self):
    def test_has_predecessor(self):
    def test_predecessors(self):
    def test_degree(self):
    def test_in_degree(self):
    def test_out_degree(self):
    def test_size(self):
    def test_to_undirected_reciprocal(self):
    def test_reverse_copy(self):
    def test_reverse_nocopy(self):
class TestMultiDiGraph(BaseMultiDiGraphTester, _TestMultiGraph):
    def setup_method(self):
    def test_add_edge(self):
    def test_add_edges_from(self):
    def test_remove_edge(self):
    def test_remove_multiedge(self):
    def test_remove_edges_from(self):
class TestEdgeSubgraph(_TestMultiGraphEdgeSubgraph):
    def setup_method(self):
class CustomDictClass(UserDict):
class SubMultiDiGraph(nx.MultiDiGraph):
class TestMultiDiGraphSubclass(TestMultiDiGraph):
    def setup_method(self):

classes/coreviews.py
class AtlasView(Mapping):
    def __getstate__(self):
    def __setstate__(self, state):
    def __init__(self, d):
    def __len__(self):
    def __iter__(self):
    def __getitem__(self, key):
    def copy(self):
    def __str__(self):
    def __repr__(self):
class AdjacencyView(AtlasView):
    def __getitem__(self, name):
    def copy(self):
class MultiAdjacencyView(AdjacencyView):
    def __getitem__(self, name):
    def copy(self):
class UnionAtlas(Mapping):
    def __getstate__(self):
    def __setstate__(self, state):
    def __init__(self, succ, pred):
    def __len__(self):
    def __iter__(self):
    def __getitem__(self, key):
    def copy(self):
    def __str__(self):
    def __repr__(self):
class UnionAdjacency(Mapping):
    def __getstate__(self):
    def __setstate__(self, state):
    def __init__(self, succ, pred):
    def __len__(self):
    def __iter__(self):
    def __getitem__(self, nbr):
    def copy(self):
    def __str__(self):
    def __repr__(self):
class UnionMultiInner(UnionAtlas):
    def __getitem__(self, node):
    def copy(self):
class UnionMultiAdjacency(UnionAdjacency):
    def __getitem__(self, node):
class FilterAtlas(Mapping):  # nodedict, nbrdict, keydict
    def __init__(self, d, NODE_OK):
    def __len__(self):
    def __iter__(self):
    def __getitem__(self, key):
    def copy(self):
    def __str__(self):
    def __repr__(self):
class FilterAdjacency(Mapping):  # edgedict
    def __init__(self, d, NODE_OK, EDGE_OK):
    def __len__(self):
    def __iter__(self):
    def __getitem__(self, node):
            def new_node_ok(nbr):
    def copy(self):
    def __str__(self):
    def __repr__(self):
class FilterMultiInner(FilterAdjacency):  # muliedge_seconddict
    def __iter__(self):
    def __getitem__(self, nbr):
            def new_node_ok(key):
    def copy(self):
class FilterMultiAdjacency(FilterAdjacency):  # multiedgedict
    def __getitem__(self, node):
            def edge_ok(nbr, key):
    def copy(self):

linalg/algebraicconnectivity.py
class _PCGSolver:
    def __init__(self, A, M):
    def solve(self, B, tol):
    def _solve(self, b, tol):
class _LUSolver:
    def __init__(self, A):
    def solve(self, B, tol=None):
def _preprocess_graph(G, weight):
def _rcm_estimate(G, nodelist):
def _tracemin_fiedler(L, X, normalized, tol, method):
        def project(X):
        def project(X):
def _get_fiedler_func(method):
        def find_fiedler(L, x, normalized, tol, seed):
        def find_fiedler(L, x, normalized, tol, seed):
def algebraic_connectivity(
def fiedler_vector(
def spectral_ordering(

conftest.py
def pytest_addoption(parser):
def pytest_configure(config):
def pytest_collection_modifyitems(config, items):
def set_warnings():
def add_nx(doctest_namespace):

readwrite/p2g.py
def write_p2g(G, path, encoding="utf-8"):
def read_p2g(path, encoding="utf-8"):
def parse_p2g(lines):

readwrite/nx_shp.py
def read_shp(path, simplify=True, geom_attrs=True, strict=True):
def edges_from_line(geom, attrs, simplify=True, geom_attrs=True):
def write_shp(G, outdir):
    def netgeometry(key, data):
    def create_feature(geometry, lyr, attributes=None):
    def add_fields_to_layer(key, value, fields, layer):
    def create_attributes(data, fields, layer):

readwrite/adjlist.py
def generate_adjlist(G, delimiter=" "):
def write_adjlist(G, path, comments="#", delimiter=" ", encoding="utf-8"):
def parse_adjlist(
def read_adjlist(

readwrite/pajek.py
def generate_pajek(G):
def write_pajek(G, path, encoding="UTF-8"):
def read_pajek(path, encoding="UTF-8"):
def parse_pajek(lines):
def make_qstr(t):

readwrite/edgelist.py
def generate_edgelist(G, delimiter=" ", data=True):
def write_edgelist(G, path, comments="#", delimiter=" ", data=True, encoding="utf-8"):
def parse_edgelist(
def read_edgelist(
def write_weighted_edgelist(G, path, comments="#", delimiter=" ", encoding="utf-8"):
def read_weighted_edgelist(

classes/graph.py
class Graph:
    def to_directed_class(self):
    def to_undirected_class(self):
    def __init__(self, incoming_graph_data=None, **attr):
    def adj(self):
    def name(self):
    def name(self, s):
    def __str__(self):
    def __iter__(self):
    def __contains__(self, n):
    def __len__(self):
    def __getitem__(self, n):
    def add_node(self, node_for_adding, **attr):
    def add_nodes_from(self, nodes_for_adding, **attr):
    def remove_node(self, n):
    def remove_nodes_from(self, nodes):
    def nodes(self):
    def number_of_nodes(self):
    def order(self):
    def has_node(self, n):
    def add_edge(self, u_of_edge, v_of_edge, **attr):
    def add_edges_from(self, ebunch_to_add, **attr):
    def add_weighted_edges_from(self, ebunch_to_add, weight="weight", **attr):
    def remove_edge(self, u, v):
    def remove_edges_from(self, ebunch):
    def update(self, edges=None, nodes=None):
    def has_edge(self, u, v):
    def neighbors(self, n):
    def edges(self):
    def get_edge_data(self, u, v, default=None):
    def adjacency(self):
    def degree(self):
    def clear(self):
    def clear_edges(self):
    def is_multigraph(self):
    def is_directed(self):
    def copy(self, as_view=False):
    def to_directed(self, as_view=False):
    def to_undirected(self, as_view=False):
    def subgraph(self, nodes):
    def edge_subgraph(self, edges):
    def size(self, weight=None):
    def number_of_edges(self, u=None, v=None):
    def nbunch_iter(self, nbunch=None):
            def bunch_iter(nlist, adj):

readwrite/graphml.py
def write_graphml_xml(
def write_graphml_lxml(
def generate_graphml(
def read_graphml(path, node_type=str, edge_key_type=int, force_multigraph=False):
def parse_graphml(
class GraphML:
    def construct_types(self):
    def get_xml_type(self, key):
class GraphMLWriter(GraphML):
    def __init__(
    def __str__(self):
    def attr_type(self, name, scope, value):
    def get_key(self, name, attr_type, scope, default):
    def add_data(self, name, element_type, value, scope="all", default=None):
    def add_attributes(self, scope, xml_obj, data, default):
    def add_nodes(self, G, graph_element):
    def add_edges(self, G, graph_element):
    def add_graph_element(self, G):
    def add_graphs(self, graph_list):
    def dump(self, stream):
    def indent(self, elem, level=0):
class IncrementalElement:
    def __init__(self, xml, prettyprint):
    def append(self, element):
class GraphMLWriterLxml(GraphMLWriter):
    def __init__(
    def add_graph_element(self, G):
    def add_attributes(self, scope, xml_obj, data, default):
    def __str__(self):
    def dump(self):
class GraphMLReader(GraphML):
    def __init__(self, node_type=str, edge_key_type=int, force_multigraph=False):
    def __call__(self, path=None, string=None):
    def make_graph(self, graph_xml, graphml_keys, defaults, G=None):
    def add_node(self, G, node_xml, graphml_keys, defaults):
    def add_edge(self, G, edge_element, graphml_keys):
    def decode_data_elements(self, graphml_keys, obj_xml):
    def find_graphml_keys(self, graph_element):

readwrite/leda.py
def read_leda(path, encoding="UTF-8"):
def parse_leda(lines):

readwrite/text.py
def forest_str(graph, with_labels=True, sources=None, write=None, ascii_only=False):

readwrite/__init__.py
def __getattr__(name):

readwrite/multiline_adjlist.py
def generate_multiline_adjlist(G, delimiter=" "):
def write_multiline_adjlist(G, path, delimiter=" ", comments="#", encoding="utf-8"):
def parse_multiline_adjlist(
def read_multiline_adjlist(

readwrite/graph6.py
def _generate_graph6_bytes(G, nodes, header):
def from_graph6_bytes(bytes_in):
    def bits():
def to_graph6_bytes(G, nodes=None, header=True):
def read_graph6(path):
def write_graph6(G, path, nodes=None, header=True):
def write_graph6_file(G, f, nodes=None, header=True):
def data_to_n(data):
def n_to_data(n):

readwrite/gpickle.py
def write_gpickle(G, path, protocol=pickle.HIGHEST_PROTOCOL):
def read_gpickle(path):

readwrite/sparse6.py
def _generate_sparse6_bytes(G, nodes, header):
    def enc(x):
def from_sparse6_bytes(string):
    def parseData():
def to_sparse6_bytes(G, nodes=None, header=True):
def read_sparse6(path):
def write_sparse6(G, path, nodes=None, header=True):

readwrite/json_graph/adjacency.py
def adjacency_data(G, attrs=_attrs):
def adjacency_graph(data, directed=False, multigraph=True, attrs=_attrs):

readwrite/json_graph/node_link.py
def _to_tuple(x):
def node_link_data(G, attrs=None):
def node_link_graph(data, directed=False, multigraph=True, attrs=None):

readwrite/json_graph/jit.py
def jit_graph(data, create_using=None):
def jit_data(G, indent=None, default=None):

readwrite/tests/test_leda.py
class TestLEDA:
    def test_parse_leda(self):
    def test_read_LEDA(self):

readwrite/json_graph/tree.py
def tree_data(G, root, attrs=None, ident="id", children="children"):
    def add_children(n, G):
def tree_graph(data, attrs=None, ident="id", children="children"):
    def add_children(parent, children_):

readwrite/json_graph/cytoscape.py
def cytoscape_data(G, attrs=None, name="name", ident="id"):
def cytoscape_graph(data, attrs=None, name="name", ident="id"):

readwrite/json_graph/tests/test_node_link.py
class TestNodeLink:
    def test_graph(self):
    def test_graph_attributes(self):
    def test_digraph(self):
    def test_multigraph(self):
    def test_graph_with_tuple_nodes(self):
    def test_unicode_keys(self):
    def test_exception(self):
    def test_string_ids(self):
    def test_custom_attrs(self):

readwrite/json_graph/tests/test_jit.py
class TestJIT:
    def test_jit(self):
    def test_jit_2(self):
    def test_jit_directed(self):
    def test_jit_multi_directed(self):
    def test_jit_round_trip(self):

readwrite/json_graph/tests/test_cytoscape.py
def test_attrs_deprecation(recwarn):
def test_graph():
def test_input_data_is_not_modified_when_building_graph():
def test_graph_attributes():
def test_digraph():
def test_multidigraph():
def test_multigraph():
def test_exception():

drawing/nx_pylab.py
def draw(G, pos=None, ax=None, **kwds):
def draw_networkx(G, pos=None, arrows=None, with_labels=True, **kwds):
def draw_networkx_nodes(
def draw_networkx_edges(
    def _draw_networkx_edges_line_collection():
    def _draw_networkx_edges_fancy_arrow_patch():
        def to_marker_edge(marker_size, marker):
        def _connectionstyle(posA, posB, *args, **kwargs):
def draw_networkx_labels(
def draw_networkx_edge_labels(
def draw_circular(G, **kwargs):
def draw_kamada_kawai(G, **kwargs):
def draw_random(G, **kwargs):
def draw_spectral(G, **kwargs):
def draw_spring(G, **kwargs):
def draw_shell(G, nlist=None, **kwargs):
def draw_planar(G, **kwargs):
def apply_alpha(colors, alpha, elem_list, cmap=None, vmin=None, vmax=None):

readwrite/json_graph/tests/test_adjacency.py
class TestAdjacency:
    def test_graph(self):
    def test_graph_attributes(self):
    def test_digraph(self):
    def test_multidigraph(self):
    def test_multigraph(self):
    def test_exception(self):

readwrite/tests/test_graphml.py
class BaseGraphML:
    def setup_class(cls):
class TestReadGraphML(BaseGraphML):
    def test_read_simple_directed_graphml(self):
    def test_read_simple_undirected_graphml(self):
    def test_read_undirected_multigraph_graphml(self):
    def test_read_undirected_multigraph_no_multiedge_graphml(self):
    def test_read_undirected_multigraph_only_ids_for_multiedges_graphml(self):
    def test_read_attribute_graphml(self):
    def test_node_default_attribute_graphml(self):
    def test_directed_edge_in_undirected(self):
    def test_undirected_edge_in_directed(self):
    def test_key_raise(self):
    def test_hyperedge_raise(self):
    def test_multigraph_keys(self):
    def test_preserve_multi_edge_data(self):
    def test_yfiles_extension(self):
    def test_bool(self):
    def test_graphml_header_line(self):
    def test_read_attributes_with_groups(self):
    def test_long_attribute_type(self):
class TestWriteGraphML(BaseGraphML):
    def setup_class(cls):
    def test_write_interface(self):
    def test_write_read_simple_directed_graphml(self):
    def test_GraphMLWriter_add_graphs(self):
    def test_write_read_simple_no_prettyprint(self):
    def test_write_read_attribute_named_key_ids_graphml(self):
    def test_write_read_attribute_numeric_type_graphml(self):
    def test_more_multigraph_keys(self):
    def test_default_attribute(self):
    def test_mixed_type_attributes(self):
    def test_str_number_mixed_type_attributes(self):
    def test_mixed_int_type_number_attributes(self):
    def test_numpy_float(self):
    def test_multigraph_to_graph(self):
    def test_write_generate_edge_id_from_attribute(self):
    def test_multigraph_write_generate_edge_id_from_attribute(self):
    def test_numpy_float64(self):
    def test_numpy_float32(self):
    def test_numpy_float64_inference(self):
    def test_unicode_attributes(self):
    def test_unicode_escape(self):
class TestXMLGraphML(TestWriteGraphML):
    def setup_class(cls):
def test_exception_for_unsupported_datatype_node_attr():
def test_exception_for_unsupported_datatype_edge_attr():
def test_exception_for_unsupported_datatype_graph_attr():

readwrite/json_graph/tests/test_tree.py
def test_graph():
def test_graph_attributes():
def test_exceptions():
def test_attrs_deprecation(recwarn):

readwrite/tests/test_text.py
def test_directed_tree_str():
def test_empty_graph():
def test_directed_multi_tree_forest():
def test_undirected_multi_tree_forest():
def test_undirected_tree_str():
def test_forest_str_errors():
def test_overspecified_sources():

readwrite/tests/test_gpickle.py
class TestGpickle:
    def setup_class(cls):
    def test_gpickle(self):
    def test_protocol(self):

readwrite/tests/test_shp.py
class TestShp:
    def setup_method(self):
        def createlayer(driver, layerType=ogr.wkbLineString):
    def deletetmp(self, drv, *paths):
    def testload(self):
        def compare_graph_paths_names(g, paths, names):
    def checkgeom(self, lyr, expected):
    def test_geometryexport(self):
    def test_attributeexport(self):
        def testattributes(lyr, graph):
    def test_nodeattributeexport(self):
    def test_wkt_export(self):
    def teardown_method(self):
def test_read_shp_nofile():
class TestMissingGeometry:
    def setup_method(self):
    def teardown_method(self):
    def setup_path(self):
    def create_shapedir(self):
    def delete_shapedir(self):
    def test_missing_geometry(self):
class TestMissingAttrWrite:
    def setup_method(self):
    def teardown_method(self):
    def setup_path(self):
    def delete_shapedir(self):
    def test_missing_attributes(self):

readwrite/tests/test_adjlist.py
class TestAdjlist:
    def setup_class(cls):
    def test_read_multiline_adjlist_1(self):
    def test_unicode(self):
    def test_latin1_err(self):
    def test_latin1(self):
    def test_parse_adjlist(self):
    def test_adjlist_graph(self):
    def test_adjlist_digraph(self):
    def test_adjlist_integers(self):
    def test_adjlist_multigraph(self):
    def test_adjlist_multidigraph(self):
    def test_adjlist_delimiter(self):
class TestMultilineAdjlist:
    def setup_class(cls):
    def test_parse_multiline_adjlist(self):
    def test_multiline_adjlist_graph(self):
    def test_multiline_adjlist_digraph(self):
    def test_multiline_adjlist_integers(self):
    def test_multiline_adjlist_multigraph(self):
    def test_multiline_adjlist_multidigraph(self):
    def test_multiline_adjlist_delimiter(self):

readwrite/tests/test_getattr_nxyaml_removal.py
def test_access_from_module():
def test_access_from_nx_namespace():
def test_access_from_readwrite_pkg():
def test_accessing_nx_yaml():

readwrite/tests/test_p2g.py
class TestP2G:
    def setup_class(cls):
    def test_read_p2g(self):
    def test_write_p2g(self):
    def test_write_read_p2g(self):

readwrite/tests/test_edgelist.py
def test_read_edgelist_no_data(data, extra_kwargs):
def test_read_weighted_edgelist():
def test_read_edgelist_with_data(data, extra_kwargs, expected):
def example_graph():
def test_parse_edgelist_no_data(example_graph):
def test_parse_edgelist_with_data_dict(example_graph):
def test_parse_edgelist_with_data_list(example_graph):
def test_parse_edgelist():
def test_comments_None():
class TestEdgelist:
    def setup_class(cls):
    def test_write_edgelist_1(self):
    def test_write_edgelist_2(self):
    def test_write_edgelist_3(self):
    def test_write_edgelist_4(self):
    def test_unicode(self):
    def test_latin1_issue(self):
    def test_latin1(self):
    def test_edgelist_graph(self):
    def test_edgelist_digraph(self):
    def test_edgelist_integers(self):
    def test_edgelist_multigraph(self):
    def test_edgelist_multidigraph(self):

readwrite/tests/test_pajek.py
class TestPajek:
    def setup_class(cls):
    def teardown_class(cls):
    def test_parse_pajek_simple(self):
    def test_parse_pajek(self):
    def test_parse_pajet_mat(self):
    def test_read_pajek(self):
    def test_write_pajek(self):
    def test_ignored_attribute(self):
    def test_noname(self):
    def test_unicode(self):

readwrite/tests/test_gml.py
class TestGraph:
    def setup_class(cls):
    def test_parse_gml_cytoscape_bug(self):
    def test_parse_gml(self):
    def test_read_gml(self):
    def test_labels_are_strings(self):
    def test_relabel_duplicate(self):
    def test_tuplelabels(self):
    def test_quotes(self):
    def test_unicode_node(self):
    def test_float_label(self):
    def test_special_float_label(self):
    def test_name(self):
    def test_graph_types(self):
    def test_data_types(self):
    def test_escape_unescape(self):
    def test_exceptions(self):
        def assert_parse_error(gml):
        def assert_generate_error(*args, **kwargs):
    def test_label_kwarg(self):
    def test_outofrange_integers(self):
def byte_file():
class TestPropertyLists:
    def test_writing_graph_with_multi_element_property_list(self):
    def test_writing_graph_with_one_element_property_list(self):
    def test_reading_graph_with_list_property(self):
    def test_reading_graph_with_single_element_list_property(self):

readwrite/tests/test_sparse6.py
class TestSparseGraph6:
    def test_from_sparse6_bytes(self):
    def test_from_bytes_multigraph_graph(self):
    def test_read_sparse6(self):
    def test_read_many_graph6(self):
class TestWriteSparse6:
    def test_null_graph(self):
    def test_trivial_graph(self):
    def test_empty_graph(self):
    def test_large_empty_graph(self):
    def test_very_large_empty_graph(self):
    def test_complete_graph(self):
    def test_no_header(self):
    def test_padding(self):
    def test_complete_bipartite(self):
    def test_read_write_inverse(self):
    def test_no_directed_graphs(self):
    def test_write_path(self):

readwrite/tests/test_graph6.py
class TestGraph6Utils:
    def test_n_data_n_conversion(self):
class TestFromGraph6Bytes:
    def test_from_graph6_bytes(self):
    def test_read_equals_from_bytes(self):
class TestReadGraph6:
    def test_read_many_graph6(self):
class TestWriteGraph6:
    def test_null_graph(self):
    def test_trivial_graph(self):
    def test_complete_graph(self):
    def test_large_complete_graph(self):
    def test_no_header(self):
    def test_complete_bipartite_graph(self):
    def test_no_directed_or_multi_graphs(self, G):
    def test_length(self):
    def test_roundtrip(self):
    def test_write_path(self):
    def test_relabeling(self, edge):
class TestToGraph6Bytes:
    def test_null_graph(self):
    def test_trivial_graph(self):
    def test_complete_graph(self):
    def test_large_complete_graph(self):
    def test_no_header(self):
    def test_complete_bipartite_graph(self):
    def test_no_directed_or_multi_graphs(self, G):
    def test_length(self):
    def test_roundtrip(self):
    def test_relabeling(self, edge):

readwrite/tests/test_gexf.py
class TestGEXF:
    def setup_class(cls):
    def test_read_simple_directed_graphml(self):
    def test_write_read_simple_directed_graphml(self):
    def test_read_simple_undirected_graphml(self):
    def test_read_attribute_graphml(self):
    def test_directed_edge_in_undirected(self):
    def test_undirected_edge_in_directed(self):
    def test_key_raises(self):
    def test_relabel(self):
    def test_default_attribute(self):
    def test_serialize_ints_to_strings(self):
    def test_write_with_node_attributes(self):
    def test_edge_id_construct(self):
    def test_numpy_type(self):
    def test_bool(self):
    def test_specials(self):
    def test_simple_list(self):
    def test_dynamic_mode(self):
    def test_multigraph_with_missing_attributes(self):
    def test_missing_viz_attributes(self):
    def test_slice_and_spell(self):
    def test_add_parent(self):

readwrite/nx_yaml.py
def __dir__():
def __getattr__(name):

readwrite/gml.py
def escape(text):
    def fixup(m):
def unescape(text):
    def fixup(m):
def literal_destringizer(rep):
def read_gml(path, label="label", destringizer=None):
    def filter_lines(lines):
def parse_gml(lines, label="label", destringizer=None):
    def decode_line(line):
    def filter_lines(lines):
class Pattern(Enum):
class Token(NamedTuple):
def parse_gml_lines(lines, label, destringizer):
    def tokenize():
    def unexpected(curr_token, expected):
    def consume(curr_token, category, expected):
    def parse_kv(curr_token):
        def clean_dict_value(value):
    def parse_dict(curr_token):
    def parse_graph():
    def pop_attr(dct, category, attr, i):
def literal_stringizer(value):
    def stringize(value):
def generate_gml(G, stringizer=None):
    def stringize(key, value, ignored_keys, indent, in_list=False):
def write_gml(G, path, stringizer=None):

drawing/nx_pydot.py
def write_dot(G, path):
def read_dot(path):
def from_pydot(P):
def to_pydot(N):
def graphviz_layout(G, prog="neato", root=None):
def pydot_layout(G, prog="neato", root=None):

drawing/nx_agraph.py
def from_agraph(A, create_using=None):
def to_agraph(N):
def write_dot(G, path):
def read_dot(path):
def graphviz_layout(G, prog="neato", root=None, args=""):
def pygraphviz_layout(G, prog="neato", root=None, args=""):
def view_pygraphviz(
    def update_attrs(which, attrs):
    def clean_attrs(which, added):
            def func(data):
def display_pygraphviz(graph, path, format=None, prog=None, args=""):

readwrite/gexf.py
def write_gexf(G, path, encoding="utf-8", prettyprint=True, version="1.2draft"):
def generate_gexf(G, encoding="utf-8", prettyprint=True, version="1.2draft"):
def read_gexf(path, node_type=None, relabel=False, version="1.2draft"):
class GEXF:
    def construct_types(self):
    def set_version(self, version):
class GEXFWriter(GEXF):
    def __init__(
    def __str__(self):
    def add_graph(self, G):
    def add_nodes(self, G, graph_element):
    def add_edges(self, G, graph_element):
        def edge_key_data(G):
    def add_attributes(self, node_or_edge, xml_obj, data, default):
    def get_attr_id(self, title, attr_type, edge_or_node, default, mode):
    def add_viz(self, element, node_data):
    def add_parents(self, node_element, node_data):
    def add_slices(self, node_or_edge_element, node_or_edge_data):
    def add_spells(self, node_or_edge_element, node_or_edge_data):
    def alter_graph_mode_timeformat(self, start_or_end):
    def write(self, fh):
    def indent(self, elem, level=0):
class GEXFReader(GEXF):
    def __init__(self, node_type=None, version="1.2draft"):
    def __call__(self, stream):
    def make_graph(self, graph_xml):
    def add_node(self, G, node_xml, node_attr, node_pid=None):
    def add_start_end(self, data, xml):
    def add_viz(self, data, node_xml):
    def add_parents(self, data, node_xml):
    def add_slices(self, data, node_or_edge_xml):
    def add_spells(self, data, node_or_edge_xml):
    def add_edge(self, G, edge_element, edge_attr):
    def decode_attr_elements(self, gexf_keys, obj_xml):
    def find_gexf_attributes(self, attributes_element):
def relabel_gexf_graph(G):

drawing/tests/test_pydot.py
class TestPydot:
    def pydot_checks(self, G, prog):
    def test_undirected(self):
    def test_directed(self):
    def test_read_write(self):

drawing/tests/test_layout.py
class TestLayout:
    def setup_class(cls):
    def test_spring_fixed_without_pos(self):
    def test_spring_init_pos(self):
    def test_smoke_empty_graph(self):
    def test_smoke_int(self):
    def test_smoke_string(self):
    def check_scale_and_center(self, pos, scale, center):
    def test_scale_and_center_arg(self):
    def test_planar_layout_non_planar_input(self):
    def test_smoke_planar_layout_embedding_input(self):
    def test_default_scale_and_center(self):
    def test_circular_planar_and_shell_dim_error(self):
    def test_adjacency_interface_numpy(self):
    def test_adjacency_interface_scipy(self):
    def test_single_nodes(self):
    def test_smoke_initial_pos_fruchterman_reingold(self):
    def test_fixed_node_fruchterman_reingold(self):
    def test_center_parameter(self):
    def test_center_wrong_dimensions(self):
    def test_empty_graph(self):
    def test_bipartite_layout(self):
    def test_multipartite_layout(self):
    def test_kamada_kawai_costfn_1d(self):
    def check_kamada_kawai_costfn(self, pos, invdist, meanwt, dim):
    def test_kamada_kawai_costfn(self):
    def test_spiral_layout(self):
    def test_spiral_layout_equidistant(self):
    def test_rescale_layout_dict(self):
def test_multipartite_layout_nonnumeric_partition_labels():

drawing/layout.py
def _process_params(G, center, dim):
def random_layout(G, center=None, dim=2, seed=None):
def circular_layout(G, scale=1, center=None, dim=2):
def shell_layout(G, nlist=None, rotate=None, scale=1, center=None, dim=2):
def bipartite_layout(
def spring_layout(
def _fruchterman_reingold(
def _sparse_fruchterman_reingold(
def kamada_kawai_layout(
def _kamada_kawai_solve(dist_mtx, pos_arr, dim):
def _kamada_kawai_costfn(pos_vec, np, invdist, meanweight, dim):
def spectral_layout(G, weight="weight", scale=1, center=None, dim=2):
def _spectral(A, dim=2):
def _sparse_spectral(A, dim=2):
def planar_layout(G, scale=1, center=None, dim=2):
def spiral_layout(G, scale=1, center=None, dim=2, resolution=0.35, equidistant=False):
def multipartite_layout(G, subset_key="subset", align="vertical", scale=1, center=None):
def rescale_layout(pos, scale=1):
def rescale_layout_dict(pos, scale=1):

drawing/tests/test_pylab.py
def test_draw():
def test_draw_shell_nlist():
def test_edge_colormap():
def test_arrows():
def test_single_edge_color_undirected(edge_color, expected, edgelist):
def test_single_edge_color_directed(edge_color, expected, edgelist):
def test_edge_color_tuple_interpretation():
def test_fewer_edge_colors_than_num_edges_directed():
def test_more_edge_colors_than_num_edges_directed():
def test_edge_color_string_with_gloabl_alpha_undirected():
def test_edge_color_string_with_global_alpha_directed():
def test_edge_width_default_value(graph_type):
def test_edge_width_single_value_undirected(edgewidth, expected):
def test_edge_width_single_value_directed(edgewidth, expected):
def test_edge_width_sequence(edgelist):
def test_edge_color_with_edge_vmin_vmax():
def test_directed_edges_linestyle_default():
def test_directed_edges_linestyle_single_value(style):
def test_directed_edges_linestyle_sequence(style_seq):
def test_labels_and_colors():
def test_house_with_colors():
def test_axes():
def test_empty_graph():
def test_draw_empty_nodes_return_values():
def test_multigraph_edgelist_tuples():
def test_alpha_iter():
def test_error_invalid_kwds():
def test_draw_networkx_arrowsize_incorrect_size():
def test_draw_edges_arrowsize(arrowsize):
def test_np_edgelist():
def test_draw_nodes_missing_node_from_position():
def test_draw_edges_min_source_target_margins(node_shape):
def test_nonzero_selfloop_with_single_node():
def test_nonzero_selfloop_with_single_edge_in_edgelist():
def test_apply_alpha():
def test_draw_edges_toggling_with_arrows_kwarg():
def test_draw_networkx_arrows_default_undirected(drawing_func):
def test_draw_networkx_arrows_default_directed(drawing_func):
def test_edgelist_kwarg_not_ignored():
def test_draw_networkx_edge_label_multiedge_exception():
def test_draw_networkx_edge_label_empty_dict():
def test_draw_networkx_edges_undirected_selfloop_colors():

drawing/tests/test_agraph.py
class TestAGraph:
    def build_graph(self, G):
    def assert_equal(self, G1, G2):
    def agraph_checks(self, G):
    def test_from_agraph_name(self):
    def test_from_agraph_create_using(self, graph_class):
    def test_from_agraph_named_edges(self):
    def test_undirected(self):
    def test_directed(self):
    def test_multi_undirected(self):
    def test_multi_directed(self):
    def test_to_agraph_with_nodedata(self):
    def test_to_agraph_with_edgedata(self, graph_class):
    def test_view_pygraphviz_path(self, tmp_path):
    def test_view_pygraphviz_file_suffix(self, tmp_path):
    def test_view_pygraphviz(self):
    def test_view_pygraphviz_edgelabel(self):
    def test_view_pygraphviz_callable_edgelabel(self):
        def foo_label(data):
    def test_view_pygraphviz_multigraph_edgelabels(self):
    def test_graph_with_reserved_keywords(self):
    def test_view_pygraphviz_no_added_attrs_to_input(self):
    def test_view_pygraphviz_leaves_input_graph_unmodified(self):
    def test_graph_with_AGraph_attrs(self):
    def test_round_trip_empty_graph(self):
    def test_round_trip_integer_nodes(self):
    def test_graphviz_alias(self):
    def test_pygraphviz_layout_root(self, root):
    def test_2d_layout(self):
    def test_3d_layout(self):
